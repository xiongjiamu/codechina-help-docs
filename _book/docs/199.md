# GitLab CI/CD pipeline configuration reference

> 原文：[https://docs.gitlab.com/ee/ci/yaml/README.html](https://docs.gitlab.com/ee/ci/yaml/README.html)

*   [Introduction](#introduction)
    *   [Validate the `.gitlab-ci.yml`](#validate-the-gitlab-ciyml)
    *   [Unavailable names for jobs](#unavailable-names-for-jobs)
    *   [Using reserved keywords](#using-reserved-keywords)
*   [Configuration parameters](#configuration-parameters)
*   [Global parameters](#global-parameters)
    *   [Global defaults](#global-defaults)
        *   [`inherit`](#inherit)
    *   [`stages`](#stages)
    *   [`workflow:rules`](#workflowrules)
        *   [`workflow:rules` templates](#workflowrules-templates)
    *   [`include`](#include)
        *   [`include:local`](#includelocal)
        *   [`include:file`](#includefile)
        *   [`include:remote`](#includeremote)
        *   [`include:template`](#includetemplate)
        *   [Nested includes](#nested-includes)
        *   [Additional `includes` examples](#additional-includes-examples)
*   [Parameter details](#parameter-details)
    *   [`image`](#image)
        *   [`image:name`](#imagename)
        *   [`image:entrypoint`](#imageentrypoint)
        *   [`services`](#services)
            *   [`services:name`](#servicesname)
            *   [`services:alias`](#servicesalias)
            *   [`services:entrypoint`](#servicesentrypoint)
            *   [`services:command`](#servicescommand)
    *   [`script`](#script)
        *   [`before_script` and `after_script`](#before_script-and-after_script)
        *   [Coloring script output](#coloring-script-output)
        *   [Multiline commands](#multiline-commands)
    *   [`stage`](#stage)
        *   [Using your own Runners](#using-your-own-runners)
        *   [`.pre` and `.post`](#pre-and-post)
    *   [`extends`](#extends)
        *   [Merge details](#merge-details)
        *   [Using `extends` and `include` together](#using-extends-and-include-together)
    *   [`rules`](#rules)
        *   [Rules attributes](#rules-attributes)
        *   [Rules clauses](#rules-clauses)
        *   [Differences between `rules` and `only`/`except`](#differences-between-rules-and-onlyexcept)
            *   [`rules:if`](#rulesif)
            *   [`rules:changes`](#ruleschanges)
            *   [`rules:exists`](#rulesexists)
            *   [`rules:allow_failure`](#rulesallow_failure)
        *   [Complex rule clauses](#complex-rule-clauses)
    *   [`only`/`except` (basic)](#onlyexcept-basic)
        *   [Regular expressions](#regular-expressions)
        *   [Supported `only`/`except` regexp syntax](#supported-onlyexcept-regexp-syntax)
    *   [`only`/`except` (advanced)](#onlyexcept-advanced)
        *   [`only:refs`/`except:refs`](#onlyrefsexceptrefs)
        *   [`only:kubernetes`/`except:kubernetes`](#onlykubernetesexceptkubernetes)
        *   [`only:variables`/`except:variables`](#onlyvariablesexceptvariables)
        *   [`only:changes`/`except:changes`](#onlychangesexceptchanges)
            *   [Using `only:changes` with pipelines for merge requests](#using-onlychanges-with-pipelines-for-merge-requests)
            *   [Using `only:changes` without pipelines for merge requests](#using-onlychanges-without-pipelines-for-merge-requests)
            *   [Using `only:changes` with scheduled pipelines](#using-onlychanges-with-scheduled-pipelines)
    *   [`needs`](#needs)
        *   [Requirements and limitations](#requirements-and-limitations)
            *   [Changing the `needs:` job limit](#changing-the-needs-job-limit)
        *   [Artifact downloads with `needs`](#artifact-downloads-with-needs)
        *   [Cross project artifact downloads with `needs`](#cross-project-artifact-downloads-with-needs-premium)
            *   [Artifact downloads between pipelines in the same project](#artifact-downloads-between-pipelines-in-the-same-project)
    *   [`tags`](#tags)
    *   [`allow_failure`](#allow_failure)
    *   [`when`](#when)
        *   [`when:manual`](#whenmanual)
            *   [Protecting manual jobs](#protecting-manual-jobs-premium)
        *   [`when:delayed`](#whendelayed)
    *   [`environment`](#environment)
        *   [`environment:name`](#environmentname)
        *   [`environment:url`](#environmenturl)
        *   [`environment:on_stop`](#environmenton_stop)
        *   [`environment:action`](#environmentaction)
        *   [`environment:auto_stop_in`](#environmentauto_stop_in)
        *   [`environment:kubernetes`](#environmentkubernetes)
        *   [Dynamic environments](#dynamic-environments)
    *   [`cache`](#cache)
        *   [`cache:paths`](#cachepaths)
        *   [`cache:key`](#cachekey)
            *   [`cache:key:files`](#cachekeyfiles)
            *   [`cache:key:prefix`](#cachekeyprefix)
        *   [`cache:untracked`](#cacheuntracked)
        *   [`cache:policy`](#cachepolicy)
    *   [`artifacts`](#artifacts)
        *   [`artifacts:paths`](#artifactspaths)
        *   [`artifacts:exclude`](#artifactsexclude)
        *   [`artifacts:expose_as`](#artifactsexpose_as)
        *   [`artifacts:name`](#artifactsname)
        *   [`artifacts:untracked`](#artifactsuntracked)
        *   [`artifacts:when`](#artifactswhen)
        *   [`artifacts:expire_in`](#artifactsexpire_in)
        *   [`artifacts:reports`](#artifactsreports)
        *   [`dependencies`](#dependencies)
            *   [When a dependent job will fail](#when-a-dependent-job-will-fail)
    *   [`coverage`](#coverage)
    *   [`retry`](#retry)
    *   [`timeout`](#timeout)
    *   [`parallel`](#parallel)
    *   [`trigger`](#trigger)
        *   [Simple `trigger` syntax for multi-project pipelines](#simple-trigger-syntax-for-multi-project-pipelines)
        *   [Complex `trigger` syntax for multi-project pipelines](#complex-trigger-syntax-for-multi-project-pipelines)
        *   [`trigger` syntax for child pipeline](#trigger-syntax-for-child-pipeline)
            *   [Trigger child pipeline with generated configuration file](#trigger-child-pipeline-with-generated-configuration-file)
        *   [Linking pipelines with `trigger:strategy`](#linking-pipelines-with-triggerstrategy)
        *   [Trigger a pipeline by API call](#trigger-a-pipeline-by-api-call)
    *   [`interruptible`](#interruptible)
    *   [`resource_group`](#resource_group)
    *   [`release`](#release)
        *   [`release-cli` Docker image](#release-cli-docker-image)
        *   [Script](#script-1)
        *   [`release:tag_name`](#releasetag_name)
        *   [`release:name`](#releasename)
        *   [`release:description`](#releasedescription)
        *   [`release:ref`](#releaseref)
        *   [`release:milestones`](#releasemilestones)
        *   [`release:released_at`](#releasereleased_at)
        *   [Complete example for `release`](#complete-example-for-release)
        *   [`releaser-cli` command line](#releaser-cli-command-line)
    *   [`pages`](#pages)
*   [`variables`](#variables)
    *   [Git strategy](#git-strategy)
    *   [Git submodule strategy](#git-submodule-strategy)
    *   [Git checkout](#git-checkout)
    *   [Git clean flags](#git-clean-flags)
    *   [Git fetch extra flags](#git-fetch-extra-flags)
    *   [Job stages attempts](#job-stages-attempts)
    *   [Shallow cloning](#shallow-cloning)
    *   [Custom build directories](#custom-build-directories)
        *   [Handling concurrency](#handling-concurrency)
        *   [Nested paths](#nested-paths)
*   [Special YAML features](#special-yaml-features)
    *   [Anchors](#anchors)
        *   [YAML anchors for `before_script` and `after_script`](#yaml-anchors-for-before_script-and-after_script)
        *   [YAML anchors for `script`](#yaml-anchors-for-script)
        *   [YAML anchors for variables](#yaml-anchors-for-variables)
    *   [Hide jobs](#hide-jobs)
*   [Skip Pipeline](#skip-pipeline)
*   [Processing Git pushes](#processing-git-pushes)
*   [Deprecated parameters](#deprecated-parameters)
    *   [Globally-defined `types`](#globally-defined-types)
    *   [Job-defined `type`](#job-defined-type)
    *   [Globally-defined `image`, `services`, `cache`, `before_script`, `after_script`](#globally-defined-image-services-cache-before_script-after_script)

# GitLab CI/CD pipeline configuration reference[](#gitlab-cicd-pipeline-configuration-reference "Permalink")

在每个项目中，使用名为`.gitlab-ci.yml`的 YAML 文件配置 GitLab CI / CD [管道](../pipelines/index.html) .

`.gitlab-ci.yml`文件定义管道的结构和顺序，并确定：

*   使用[GitLab Runner](https://docs.gitlab.com/runner/)执行什么.
*   遇到特定条件时要做出什么决定. 例如，当一个过程成功或失败时.

本主题涵盖 CI / CD 管道配置. 有关其他 CI / CD 配置信息，请参阅：

*   [GitLab CI / CD 变量](../variables/README.html) ，用于配置运行管道的环境.
*   [GitLab Runner 高级配置](https://docs.gitlab.com/runner/configuration/advanced-configuration.html) ，用于配置 GitLab Runner.

我们有配置管道的完整示例：

*   有关 GitLab CI / CD 的快速介绍，请遵循我们的[快速入门指南](../quick_start/README.html) .
*   有关示例集合，请参见[GitLab CI / CD 示例](../examples/README.html) .
*   要看到一个大`.gitlab-ci.yml`在企业使用的文件，看到[`.gitlab-ci.yml`文件`gitlab`](https://gitlab.com/gitlab-org/gitlab/blob/master/.gitlab-ci.yml) .

> 有关 GitLab CI / CD 的其他信息：
> 
> *   观看[CI / CD 轻松配置](https://www.youtube.com/embed/opdLqwz6tcE)视频.
> *   [在组织的](https://about.gitlab.com/compare/github-actions-alternative/)网络广播中观看" [为 CI / CD](https://about.gitlab.com/compare/github-actions-alternative/)辩护"，以了解 CI / CD 的好处以及如何衡量 CI / CD 自动化的结果.
> *   了解[Verizon](https://about.gitlab.com/blog/2019/02/14/verizon-customer-story/)如何使用 GitLab [将重建工作](https://about.gitlab.com/blog/2019/02/14/verizon-customer-story/)从 30 天[减少](https://about.gitlab.com/blog/2019/02/14/verizon-customer-story/)到 8 小时以下.

**注意：**如果您有[从 GitLab 提取镜像的存储库](../../user/project/repository/repository_mirroring.html#pulling-from-a-remote-repository-starter) ，则可能需要在项目的**"设置">"存储库">"从远程存储库中提取">"触发管道更新镜像"中**启用管道触发.

## Introduction[](#introduction "Permalink")

管道配置从作业开始. 作业是`.gitlab-ci.yml`文件的最基本元素.

工作是：

*   定义了约束，指出应在什么条件下执行它们.
*   具有任意名称的顶级元素，并且必须至少包含[`script`](#script)子句.
*   不限制可以定义多少个.

例如：

```
job1:
  script: "execute-script-for-job1"

job2:
  script: "execute-script-for-job2" 
```

上面的示例是具有两个单独作业的最简单的 CI / CD 配置，其中每个作业执行一个不同的命令. 当然，命令可以直接执行代码（ `./configure;make;make install` ）或在存储库中运行脚本（ `test.sh` ）.

乔布斯被拾起[运动员](../runners/README.html)和跑步者的环境中执行. 重要的是，每个作业彼此独立运行.

### Validate the `.gitlab-ci.yml`[](#validate-the-gitlab-ciyml "Permalink")

GitLab CI / CD 的每个实例都有一个称为 Lint 的嵌入式调试工具，该工具可以验证`.gitlab-ci.yml`文件的内容. 您可以在项目名称空间的`ci/lint`页下找到 Lint. 例如， `https://gitlab.example.com/gitlab-org/project-123/-/ci/lint` .

### Unavailable names for jobs[](#unavailable-names-for-jobs "Permalink")

每个作业必须具有唯一的名称，但是有一些**保留的`keywords`不能用作作业名称** ：

*   `image`
*   `services`
*   `stages`
*   `types`
*   `before_script`
*   `after_script`
*   `variables`
*   `cache`
*   `include`

### Using reserved keywords[](#using-reserved-keywords "Permalink")

如果在使用特定值（例如`true`或`false` ）时收到验证错误，请尝试执行以下操作：

*   引用他们.
*   将它们更改为其他形式. 例如， `/bin/true` .

## Configuration parameters[](#configuration-parameters "Permalink")

作业定义为定义作业行为的参数列表.

下表列出了作业的可用参数：

| Keyword | Description |
| --- | --- |
| [`script`](#script) | 由 Runner 执行的 Shell 脚本. |
| [`image`](#image) | 使用 Docker 映像 也可用： `image:name`和`image:entrypoint` . |
| [`services`](#services) | Use Docker services images. Also available: `services:name`, `services:alias`, `services:entrypoint`, and `services:command`. |
| [`before_script`](#before_script-and-after_script) | 覆盖作业之前执行的一组命令. |
| [`after_script`](#before_script-and-after_script) | 覆盖作业后执行的一组命令. |
| [`stage`](#stage) | 定义一个工作阶段（默认： `test` ）. |
| [`only`](#onlyexcept-basic) | 限制创建作业的时间. 也可用： [`only:refs` ， `only:kubernetes` ， `only:variables`和`only:changes`](#onlyexcept-advanced) . |
| [`except`](#onlyexcept-basic) | 限制未创建作业的时间. 也可用： [`except:refs` ， `except:kubernetes` ， `except:variables`和`except:changes`](#onlyexcept-advanced) . |
| [`rules`](#rules) | 评估和确定作业的选定属性以及是否创建作业的条件列表. 不能`only`与/ `except`一起使用. |
| [`tags`](#tags) | 用于选择 Runner 的标签列表. |
| [`allow_failure`](#allow_failure) | 允许作业失败. 失败的作业不会影响提交状态. |
| [`when`](#when) | 什么时候开始工作. 也可用： `when:manual`和`when:delayed` . |
| [`environment`](#environment) | 作业部署到的环境的名称. 也可用： `environment:name` ， `environment:url` ， `environment:on_stop` ， `environment:auto_stop_in`和`environment:action` . |
| [`cache`](#cache) | 在后续运行之间应缓存的文件列表. 也可用： `cache:paths` ， `cache:key` ， `cache:untracked`和`cache:policy` . |
| [`artifacts`](#artifacts) | 成功时附加到作业的文件和目录列表. 也可以使用： `artifacts:paths` ， `artifacts:exclude` ， `artifacts:expose_as` ， `artifacts:name` ， `artifacts:untracked` ， `artifacts:when` ， `artifacts:expire_in` ， `artifacts:reports` ， `artifacts:reports:junit` ， `artifacts:reports:cobertura`和`artifacts:reports:terraform` .

在 GitLab [企业版](https://about.gitlab.com/pricing/) ，这些都是可供选择： `artifacts:reports:codequality` ， `artifacts:reports:sast` ， `artifacts:reports:dependency_scanning` ， `artifacts:reports:container_scanning` ， `artifacts:reports:dast` ， `artifacts:reports:license_scanning` ， `artifacts:reports:license_management` （已在 GitLab 13.0 中删除）， `artifacts:reports:performance`和`artifacts:reports:metrics` . |
| [`dependencies`](#dependencies) | 通过提供要从中获取工件的作业列表，限制将哪些工件传递给特定作业. |
| [`coverage`](#coverage) | 给定作业的代码覆盖率设置. |
| [`retry`](#retry) | 发生故障时可以自动重试作业的时间和次数. |
| [`timeout`](#timeout) | 定义优先于项目范围设置的自定义作业级别超时. |
| [`parallel`](#parallel) | 多少个作业实例应并行运行. |
| [`trigger`](#trigger) | 定义下游管道触发器. |
| [`include`](#include) | 允许此作业包括外部 YAML 文件. 也可用： `include:local` ， `include:file` ， `include:template`和`include:remote` . |
| [`extends`](#extends) | 该作业将要继承的配置条目. |
| [`pages`](#pages) | 上载作业结果以用于 GitLab 页面. |
| [`variables`](#variables) | 在作业级别上定义作业变量. |
| [`interruptible`](#interruptible) | 定义在通过新的运行使其冗余时是否可以取消作业. |
| [`resource_group`](#resource_group) | 限制作业并发. |
| [`release`](#release) | 指示 Runner 生成[Release](../../user/project/releases/index.html)对象. |

**Note:** Parameters `types` and `type` are [deprecated](#deprecated-parameters).

## Global parameters[](#global-parameters "Permalink")

必须在全局级别定义一些参数，这会影响管道中的所有作业.

### Global defaults[](#global-defaults "Permalink")

可以使用`default:`关键字将某些参数全局设置为所有作业的`default:` . 然后可以通过特定于作业的配置覆盖默认参数.

可以在`default:`块内定义以下作业参数：

*   [`image`](#image)
*   [`services`](#services)
*   [`before_script`](#before_script-and-after_script)
*   [`after_script`](#before_script-and-after_script)
*   [`tags`](#tags)
*   [`cache`](#cache)
*   [`artifacts`](#artifacts)
*   [`retry`](#retry)
*   [`timeout`](#timeout)
*   [`interruptible`](#interruptible)

在以下示例中，除了`rspec 2.6`作业（使用`ruby:2.6`图像）以外，所有作业的默认设置都是`ruby:2.5`图像：

```
default:
  image: ruby:2.5

rspec:
  script: bundle exec rspec

rspec 2.6:
  image: ruby:2.6
  script: bundle exec rspec 
```

#### `inherit`[](#inherit "Permalink")

在 GitLab 12.9 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/207484) .

您可以使用`inherit:`参数禁用对全局定义的默认值和变量的`inherit:` .

要启用或禁用所有`variables:`或`default:`参数的继承，请使用以下格式：

*   `default: true` or `default: false`
*   `variables: true` or `variables: false`

要仅继承`default:`参数或`variables:`的子集，请指定要继承的内容，未列出的任何内容均**不会**被继承. 使用以下格式之一：

```
inherit:
  default: [parameter1, parameter2]
  variables: [VARIABLE1, VARIABLE2] 
```

Or:

```
inherit:
  default:
    - parameter1
    - parameter2
  variables:
    - VARIABLE1
    - VARIABLE2 
```

在以下示例中：

*   `rubocop`:
    *   **会**继承：没有.
*   `rspec`:
    *   **将**继承：默认`image`和`WEBHOOK_URL`变量.
    *   **不会**继承：默认的`before_script`和`DOMAIN`变量.
*   `capybara`:
    *   **将**继承：默认的`before_script`和`image` .
    *   将**不会**继承： `DOMAIN`和`WEBHOOK_URL`变量.
*   `karma`:
    *   **将**继承：默认`image` ， `before_script`和`DOMAIN`变量.
    *   will **not** inherit: `WEBHOOK_URL` variable.

```
default:
  image: 'ruby:2.4'
  before_script:
    - echo Hello World

variables:
  DOMAIN: example.com
  WEBHOOK_URL: https://my-webhook.example.com

rubocop:
  inherit:
    default: false
    variables: false
  script: bundle exec rubocop

rspec:
  inherit:
    default: [image]
    variables: [WEBHOOK_URL]
  script: bundle exec rspec

capybara:
  inherit:
    variables: false
  script: bundle exec capybara

karma:
  inherit:
    default: true
    variables: [DOMAIN]
  script: karma 
```

### `stages`[](#stages "Permalink")

`stages`用于定义包含作业的阶段，并且为管道全局定义.

的规范`stages`允许具有灵活的多阶段流水线. `stages`中元素的顺序定义了作业执行的顺序：

1.  同一阶段的作业并行运行.
2.  前一阶段的作业成功完成后，将运行下一阶段的作业.

让我们考虑以下示例，该示例定义了 3 个阶段：

```
stages:
  - build
  - test
  - deploy 
```

1.  首先，所有`build`作业均并行执行.
2.  如果所有`build`作业均成功，则`test`作业将并行执行.
3.  如果所有`test`作业均成功，则将并行执行`deploy`作业.
4.  如果所有`deploy`作业均成功，则将提交标记为`passed` .
5.  如果先前的任何作业失败，则将提交标记为`failed`并且不执行后续阶段的作业.

还有两个边缘情况值得一提：

1.  如果`.gitlab-ci.yml`中未定义任何`stages` ，则默认允许将`build` ， `test`和`deploy`用作作业的阶段.
2.  如果作业未指定`stage` ，则为该作业分配`test`阶段.

### `workflow:rules`[](#workflowrules "Permalink")

在 GitLab 12.5 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/29654)

顶级`workflow:`关键字适用于整个管道，并将确定是否创建管道. 当前，它接受一个`rules:`与[`rules:`](#rules)类似的键：在 job 中[定义](#rules) ，可动态配置管道.

如果您不熟悉 GitLab CI / CD 和`workflow: rules` ，则可能会发现[`workflow:rules`模板](#workflowrules-templates)很有用.

要定义自己的`workflow: rules` ，当前可用的配置选项为：

*   [`if`](#rulesif) ：定义规则.
*   [`when`](#when) ：可以设置为`always`或`never` . 如果未提供，则默认值`always` .

评估`if`规则的列表，直到匹配单个规则. 如果没有比赛，最后`when`会被使用：

```
workflow:
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /-wip$/
      when: never
    - if: $CI_COMMIT_TAG
      when: never
    - when: always 
```

#### `workflow:rules` templates[](#workflowrules-templates "Permalink")

在 GitLab 13.0 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/217732) .

我们提供预制模板，供您用于设置`workflow: rules`管道使用`workflow: rules`常见方案的`workflow: rules` . 使用这些将使事情变得容易，并防止重复的管道运行.

[`Branch-Pipelines`模板](https://gitlab.com/gitlab-org/gitlab/-/tree/master/lib/gitlab/ci/templates/Workflows/Branch-Pipelines.gitlab-ci.yml)使您的管道针对分支和标签运行.

分支管道状态将显示在使用该分支作为源的合并请求中，但是此管道类型不支持" [合并请求管道"](../merge_request_pipelines/)提供的任何功能，例如["合并结果管道"](../merge_request_pipelines/#pipelines-for-merged-results-premium)或" [合并训练"](../merge_request_pipelines/pipelines_for_merged_results/merge_trains/) . 如果您有意避免使用这些功能，请使用此模板.

它[包括](#include)以下内容：

```
include:
  - template: 'Workflows/Branch-Pipelines.gitlab-ci.yml' 
```

The [`MergeRequest-Pipelines` template](https://gitlab.com/gitlab-org/gitlab/-/tree/master/lib/gitlab/ci/templates/Workflows/MergeRequest-Pipelines.gitlab-ci.yml) makes your pipelines run for the default branch (usually `master`), tags, and all types of merge request pipelines. Use this template if you use any of the the [Pipelines for Merge Requests features](../merge_request_pipelines/), as mentioned above.

它[包括](#include)以下内容：

```
include:
  - template: 'Workflows/MergeRequest-Pipelines.gitlab-ci.yml' 
```

### `include`[](#include "Permalink")

版本历史

*   在[GitLab Premium](https://about.gitlab.com/pricing/) 10.5 中引入.
*   自 10.6 开始适用于 Starter，Premium 和 Ultimate.
*   在 11.4 中[移至](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/42861) GitLab Core.

使用`include`关键字允许包含外部 YAML 文件. 这有助于将 CI / CD 配置分解为多个文件，并提高了长配置文件的可读性. 也可以将模板文件存储在中央存储库中，并且项目包括其配置文件. 这有助于避免重复配置，例如，所有项目的全局默认变量.

`include`要求外部 YAML 文件具有扩展名`.yml`或`.yaml` ，否则将不包含外部文件.

`include`支持以下包含方法：

| Method | Description |
| --- | --- |
| [`local`](#includelocal) | 包括来自本地项目存储库的文件. |
| [`file`](#includefile) | 包括来自其他项目存储库的文件. |
| [`remote`](#includeremote) | 包括来自远程 URL 的文件. 必须公开可用. |
| [`template`](#includetemplate) | 包括由 GitLab 提供的模板. |

`include`方法不支持[变量扩展](../variables/where_variables_can_be_used.html#variables-usage) .

**注意：**所有方法包含的`.gitlab-ci.yml`配置在创建管道时进行评估. 该配置是及时的快照，并保留在数据库中. 在创建下一个管道之前，对引用的`.gitlab-ci.yml`配置的任何更改都不会反映在 GitLab 中.

`include`定义的文件是：

*   与`.gitlab-ci.yml`那些合并.
*   无论`include`关键字的位置如何，始终首先评估并与`.gitlab-ci.yml`的内容合并.

**提示：**使用合并功能可以自定义和覆盖包含本地定义的 CI / CD 配置. `.gitlab-ci.yml`本地定义将覆盖包含的定义.**注意：**不支持在`include`来源的不同 YAML 文件中使用[YAML 锚](#anchors) . 您只能引用同一文件中的锚. 除了使用 YAML 定位符，您还可以使用[`extends`关键字](#extends) .

#### `include:local`[](#includelocal "Permalink")

`include:local`包含与`.gitlab-ci.yml`位于同一存储库中的文件. 使用相对于根目录（ `/` ）的完整路径进行引用.

您只能在配置文件所在的同一分支上使用 Git 当前跟踪的文件. 换句话说，使用`include:local` ，请确保`.gitlab-ci.yml`和本地文件都在同一分支上.

所有[嵌套的包含](#nested-includes)将在同一项目的范围内执行，因此可以使用本地，项目，远程或模板包含.

**注意：**不支持通过 Git 子模块路径包含本地文件.

Example:

```
include:
  - local: '/templates/.gitlab-ci-template.yml' 
```

**Tip:** Local includes can be used as a replacement for symbolic links which are not followed.

可以将其定义为简短的本地包含：

```
include: '.gitlab-ci-production.yml' 
```

#### `include:file`[](#includefile "Permalink")

在 GitLab 11.7 中[引入](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/53903) .

要在同一 GitLab 实例下包含来自另一个私有项目的`include:file` ，请使用`include:file` . 使用相对于根目录（ `/` ）的完整路径引用该文件. 例如：

```
include:
  - project: 'my-group/my-project'
    file: '/templates/.gitlab-ci-template.yml' 
```

您还可以指定`ref` ，默认值为项目的`HEAD` ：

```
include:
  - project: 'my-group/my-project'
    ref: master
    file: '/templates/.gitlab-ci-template.yml'

  - project: 'my-group/my-project'
    ref: v1.0.0
    file: '/templates/.gitlab-ci-template.yml'

  - project: 'my-group/my-project'
    ref: 787123b47f14b552955ca2786bc9542ae66fee5b # Git SHA
    file: '/templates/.gitlab-ci-template.yml' 
```

所有[嵌套的包含](#nested-includes)将在目标项目的范围内执行，因此可以使用本地（相对于目标项目），项目，远程或模板包含.

#### `include:remote`[](#includeremote "Permalink")

`include:remote`可用于通过 HTTP / HTTPS 包含来自其他位置的文件，并使用完整 URL 进行引用. 远程文件必须可以通过简单的 GET 请求公开访问，因为不支持远程 URL 中的身份验证模式. 例如：

```
include:
  - remote: 'https://gitlab.com/awesome-project/raw/master/.gitlab-ci-template.yml' 
```

所有[嵌套的 include](#nested-includes)将在没有上下文的情况下作为公共用户执行，因此仅允许另一个远程或公共项目或模板.

#### `include:template`[](#includetemplate "Permalink")

在 GitLab 11.7 中[引入](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/53445) .

`include:template`可用于包含[GitLab 随附的](https://gitlab.com/gitlab-org/gitlab/tree/master/lib/gitlab/ci/templates) `.gitlab-ci.yml`模板.

例如：

```
# File sourced from GitLab's template collection
include:
  - template: Auto-DevOps.gitlab-ci.yml 
```

Multiple `include:template` files:

```
include:
  - template: Android-Fastlane.gitlab-ci.yml
  - template: Auto-DevOps.gitlab-ci.yml 
```

所有[嵌套的包含](#nested-includes)将仅在用户许可下执行，因此可以使用项目，远程或模板包含.

#### Nested includes[](#nested-includes "Permalink")

在 GitLab 11.9 中[引入](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/56836) .

嵌套包含可让您组成一组包含.

总共允许 100 个 include，但是重复的 include 被视为配置错误.

从[GitLab 12.4 开始](https://gitlab.com/gitlab-org/gitlab/-/issues/28212) ，解析所有文件的时间限制为 30 秒.

#### Additional `includes` examples[](#additional-includes-examples "Permalink")

有可用的[其他`includes`示例](includes.html)列表.

## Parameter details[](#parameter-details "Permalink")

以下是用于配置 CI / CD 管道的参数的详细说明.

### `image`[](#image "Permalink")

用于指定要用于作业[的 Docker 映像](../docker/using_docker_images.html#what-is-an-image) .

For:

*   Simple definition examples, see [Define `image` and `services` from `.gitlab-ci.yml`](../docker/using_docker_images.html#define-image-and-services-from-gitlab-ciyml).
*   详细的使用信息，请参阅[Docker 集成](../docker/README.html)文档.

#### `image:name`[](#imagename "Permalink")

An [extended Docker configuration option](../docker/using_docker_images.html#extended-docker-configuration-options).

有关更多信息，请参阅[`image`可用设置](../docker/using_docker_images.html#available-settings-for-image) .

#### `image:entrypoint`[](#imageentrypoint "Permalink")

An [extended Docker configuration option](../docker/using_docker_images.html#extended-docker-configuration-options).

有关更多信息，请参阅[`image`可用设置](../docker/using_docker_images.html#available-settings-for-image) .

#### `services`[](#services "Permalink")

用于指定[服务 Docker 映像](../docker/using_docker_images.html#what-is-a-service) ，该映像链接到 image 中指定的基本[`image`](#image) .

For:

*   简单的定义示例，请参阅[从`.gitlab-ci.yml`定义`image`和`services`](../docker/using_docker_images.html#define-image-and-services-from-gitlab-ciyml) .
*   详细的使用信息，请参阅[Docker 集成](../docker/README.html)文档.
*   有关示例服务，请参见[GitLab CI / CD 服务](../services/README.html) .

##### `services:name`[](#servicesname "Permalink")

An [extended Docker configuration option](../docker/using_docker_images.html#extended-docker-configuration-options).

For more information, see [Available settings for `services`](../docker/using_docker_images.html#available-settings-for-services).

##### `services:alias`[](#servicesalias "Permalink")

An [extended Docker configuration option](../docker/using_docker_images.html#extended-docker-configuration-options).

有关更多信息，请参阅[`services`可用设置](../docker/using_docker_images.html#available-settings-for-services) .

##### `services:entrypoint`[](#servicesentrypoint "Permalink")

An [extended Docker configuration option](../docker/using_docker_images.html#extended-docker-configuration-options).

有关更多信息，请参阅[`services`可用设置](../docker/using_docker_images.html#available-settings-for-services) .

##### `services:command`[](#servicescommand "Permalink")

An [extended Docker configuration option](../docker/using_docker_images.html#extended-docker-configuration-options).

有关更多信息，请参阅[`services`可用设置](../docker/using_docker_images.html#available-settings-for-services) .

### `script`[](#script "Permalink")

`script`是作业所需的唯一必需关键字. 这是一个由 Runner 执行的 shell 脚本. 例如：

```
job:
  script: "bundle  exec  rspec" 
```

[脚本的 YAML 锚](#yaml-anchors-for-script)可用.

此参数还可以包含使用数组的多个命令：

```
job:
  script:
    - uname -a
    - bundle exec rspec 
```

**注意：**有时， `script`命令将需要用单引号或双引号引起来. 例如，包含冒号命令（ `:` ）需要加引号，以便被包裹的 YAML 解析器知道来解释整个事情作为一个字符串，而不是一个"键：值"对. 使用特殊字符时要小心： `:` ， `{` ， `}` ， `[` ， `]` ， `,` ， `&` ， `*` ， `#` ， `?` ， `|` ， `-` ， `<` ， `>` ， `=` `!` ， `%` ， `@` ， ``` .

如果任何脚本命令返回的退出代码都不为零，则该作业将失败，并且其他命令将不再执行. 通过将退出代码存储在变量中，可以避免此行为：

```
job:
  script:
    - false || exit_code=$?
    - if [ $exit_code -ne 0 ]; then echo "Previous command failed"; fi; 
```

#### `before_script` and `after_script`[](#before_script-and-after_script "Permalink")

在 GitLab 8.7 中引入，需要 GitLab Runner v1.2.

`before_script`用于定义一个命令，该命令应在每个作业（包括部署作业）之前，但在还原任何[工件之后运行](#artifacts) . 这必须是一个数组.

`before_script`中指定的[`script`](#script)与主脚本中指定的任何脚本串联在一起，并在单个 shell 中一起执行.

`after_script`用于定义将在每个作业（包括失败的作业）之后运行的命令. 这必须是一个数组.

`after_script`中指定的脚本在新的 shell 中执行，与任何`before_script`或`script`脚本分开. 结果，他们：

*   将当前工作目录设置回默认目录.
*   无法访问由`before_script`或`script`定义的脚本完成的更改，包括：
    *   `script`脚本中导出的命令别名和变量.
    *   在工作树之外进行更改（取决于 Runner 执行程序），例如`before_script`或`script`脚本安装的软件.
*   有一个单独的超时，硬编码为 5 分钟. 有关详细信息，请参见[相关问题](https://gitlab.com/gitlab-org/gitlab-runner/-/issues/2716) .
*   不要影响作业的退出代码. 如果`script`部分成功并且`after_script`超时或失败，则该作业将以代码`0` （ `Job Succeeded` ）退出.

如果按工作设置全局定义的`before_script`或`after_script`则有可能覆盖它：

```
default:
  before_script:
    - global before script

job:
  before_script:
    - execute this instead of global before script
  script:
    - my command
  after_script:
    - execute this after my script 
```

[YAML anchors for `before_script` and `after_script`](#yaml-anchors-for-before_script-and-after_script) are available.

#### Coloring script output[](#coloring-script-output "Permalink")

脚本输出可以使用[ANSI 转义码](https://en.wikipedia.org/wiki/ANSI_escape_code#Colors)或运行输出 ANSI 转义码的命令或程序来着色.

例如，使用[带有颜色代码的 Bash](https://misc.flogisoft.com/bash/tip_colors_and_formatting) ：

```
job:
  script:
    - echo -e "\e[31mThis text is red,\e[0m but this text isn't\e[31m however this text is red again." 
```

您可以在 Shell 变量甚至[自定义环境变量中](../variables/README.html#custom-environment-variables)定义颜色代码，这使命令更易于阅读和重用.

例如，使用与上述相同的示例以及在`before_script`定义的变量：

```
job:
  before_script:
    - TXT_RED="\e[31m" && TXT_CLEAR="\e[0m"
  script:
    - echo -e "${TXT_RED}This text is red,${TXT_CLEAR} but this part isn't${TXT_RED} however this part is again."
    - echo "This text is not colored" 
```

或使用[PowerShell 颜色代码](https://superuser.com/a/1259916) ：

```
job:
  before_script:
    - $esc="$([char]27)"; $TXT_RED="$esc[31m"; $TXT_CLEAR="$esc[0m"
  script:
    - Write-Host $TXT_RED"This text is red,"$TXT_CLEAR" but this text isn't"$TXT_RED" however this text is red again."
    - Write-Host "This text is not colored" 
```

#### Multiline commands[](#multiline-commands "Permalink")

您可以使用[`|`](https://yaml-multiline.info/)将长命令分成多行命令以提高可读性[`|`](https://yaml-multiline.info/) [（文字）和`>` （折叠）YAML 多行块标量指标](https://yaml-multiline.info/) .

**警告：**如果将多个命令组合到一个命令字符串中，则只会报告最后一个命令的失败或成功， [错误地忽略了由于 bug 导致的先前命令的失败](https://gitlab.com/gitlab-org/gitlab-runner/-/issues/25394) . 如果作业的成功取决于这些命令的成功或失败，则可以将命令作为单独的`script:`项目运行，或在需要时将`exit 1`命令添加到适当的命令字符串中.

您可以使用`|` （文字）YAML 多行块标量指示器，用于在作业描述的`script`部分中的多行上编写命令. 每行都被视为一个单独的命令. 在作业日志中仅重复第一个命令，但仍执行其他命令：

```
job:
  script:
    - |
      echo "First command line."
      echo "Second command line."
      echo "Third command line." 
```

上面的示例在作业日志中呈现为：

```
$ echo First command line # collapsed multi-line command
First command line
Second command line.
Third command line. 
```

`>` （折叠的）YAML 多行块标量指示符将节之间的空行视为新命令的开始：

```
job:
  script:
    - >
      echo "First command line
      is split over two lines."

      echo "Second command line." 
```

这与编写不带`>`或`|`多行命令的行为类似 块标量指标：

```
job:
  script:
    - echo "First command line
      is split over two lines."

      echo "Second command line." 
```

上面的两个示例在作业日志中均显示为：

```
$ echo First command line is split over two lines. # collapsed multi-line command
First command line is split over two lines.
Second command line. 
```

当`>`或`|` 块标量指示符被省略，GitLab 将通过连接非空行来形成命令，因此请确保在连接时行可以运行.

[此处的](https://en.wikipedia.org/wiki/Here_document) Shell [文件可](https://en.wikipedia.org/wiki/Here_document)与`|` 和`>`运算符. 下面的示例将小写字母音译为大写字母：

```
job:
  script:
    - |
      tr a-z A-Z << END_TEXT
        one two three
        four five six
      END_TEXT 
```

结果是：

```
$ tr a-z A-Z << END_TEXT # collapsed multi-line command
  ONE TWO THREE
  FOUR FIVE SIX 
```

### `stage`[](#stage "Permalink")

`stage`是按职位定义的，并且依赖于全局定义的[`stages`](#stages) . 它允许将作业分为不同的阶段，并且同一`stage`作业可以并行执行（取决于[特定条件](#using-your-own-runners) ）. 例如：

```
stages:
  - build
  - test
  - deploy

job 0:
  stage: .pre
  script: make something useful before build stage

job 1:
  stage: build
  script: make build dependencies

job 2:
  stage: build
  script: make build artifacts

job 3:
  stage: test
  script: make test

job 4:
  stage: deploy
  script: make deploy

job 5:
  stage: .post
  script: make something useful at the end of pipeline 
```

#### Using your own Runners[](#using-your-own-runners "Permalink")

使用自己的 Runners 时，默认情况下，GitLab Runner 一次仅运行一个作业（有关更多信息，请参见[Runner 全局设置中](https://docs.gitlab.com/runner/configuration/advanced-configuration.html)的`concurrent`标志）.

仅在以下情况下，作业将在您自己的跑步者上并行运行：

*   Run on different Runners.
*   跑步者的`concurrent`设置已更改.

#### `.pre` and `.post`[](#pre-and-post "Permalink")

在 GitLab 12.4 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/31441) .

每个管道均可使用以下阶段：

*   `.pre` ，它始终是管道中的第一阶段.
*   `.post` ，它始终是管道中的最后一个阶段.

用户定义的阶段在`.pre`之后和`.post`之前执行.

即使`.gitlab-ci.yml`定义不正确， `.pre`和`.post`的顺序也无法更改. 例如，以下是等效配置：

*   按顺序配置：

    ```
    stages:
      - .pre
      - a
      - b
      - .post 
    ```

*   配置乱序：

    ```
    stages:
      - a
      - .pre
      - b
      - .post 
    ```

*   未明确配置：

    ```
    stages:
      - a
      - b 
    ```

**Note:** A pipeline won’t be created if it only contains jobs in `.pre` or `.post` stages.

### `extends`[](#extends "Permalink")

在 GitLab 11.3 中引入.

`extends`定义使用`extends`的作业将要继承的条目名称.

它是使用[YAML 锚点](#anchors)的替代方法，并且更具灵活性和可读性：

```
.tests:
  script: rake test
  stage: test
  only:
    refs:
      - branches

rspec:
  extends: .tests
  script: rake rspec
  only:
    variables:
      - $RSPEC 
```

在上面的示例中， `rspec`作业继承自`.tests`模板作业. GitLab 将基于密钥执行反向深度合并. GitLab 将：

*   Merge the `rspec` contents into `.tests` recursively.
*   不合并键的值.

这将导致以下`rspec`作业：

```
rspec:
  script: rake rspec
  stage: test
  only:
    refs:
      - branches
    variables:
      - $RSPEC 
```

**注意：**请注意， `script: rake test`已被`script: rake rspec`覆盖.

如果您确实希望包含`rake test` ，请参见[`before_script`和`after_script`](#before_script-and-after_script) .

在此示例中， `.tests`是[隐藏作业](#hide-jobs) ，但是也可以从常规作业继承.

`extends`支持多级继承，但是不建议使用三个以上级别. 支持的最大嵌套级别为 10.以下示例具有两个继承级别：

```
.tests:
  only:
    - pushes

.rspec:
  extends: .tests
  script: rake rspec

rspec 1:
  variables:
    RSPEC_SUITE: '1'
  extends: .rspec

rspec 2:
  variables:
    RSPEC_SUITE: '2'
  extends: .rspec

spinach:
  extends: .tests
  script: rake spinach 
```

在 GitLab 12.0 和更高版本中，还可以使用多个父对象进行`extends` .

#### Merge details[](#merge-details "Permalink")

`extends`可以合并哈希，但不能合并数组. 用于合并的算法是"最近的范围获胜"，因此来自最后一个成员的键将始终覆盖在其他级别定义的任何内容. 例如：

```
.only-important:
  variables:
    URL: "http://my-url.internal"
    IMPORTANT_VAR: "the  details"
  only:
    - master
    - stable
  tags:
    - production
  script:
    - echo "Hello world!"

.in-docker:
  variables:
    URL: "http://docker-url.internal"
  tags:
    - docker
  image: alpine

rspec:
  variables:
    GITLAB: "is-awesome"
  extends:
    - .only-important
    - .in-docker
  script:
    - rake rspec 
```

这将导致以下`rspec`作业：

```
rspec:
  variables:
    URL: "http://docker-url.internal"
    IMPORTANT_VAR: "the  details"
    GITLAB: "is-awesome"
  only:
    - master
    - stable
  tags:
    - docker
  image: alpine
  script:
    - rake rspec 
```

请注意，在上面的示例中：

*   `variables`部分已合并，但`URL: "http://my-url.internal"`已被`URL: "http://docker-url.internal"`覆盖.
*   `tags: ['production']`已被`tags: ['docker']`覆盖.
*   `script`尚未合并，而是`script: ['echo "Hello world!"']`被`script: ['rake rspec']`覆盖. 可以使用[YAML 锚点](#anchors)合并数组.

#### Using `extends` and `include` together[](#using-extends-and-include-together "Permalink")

`extends`配置文件`extends`到`include`配置文件.

例如，如果您有本地`included.yml`文件：

```
.template:
  script:
    - echo Hello! 
```

然后，在`.gitlab-ci.yml`您可以像这样使用它：

```
include: included.yml

useTemplate:
  image: alpine
  extends: .template 
```

这将运行一个名为`useTemplate`的作业，该作业运行`echo Hello!` 如`.template`作业中所定义，并使用本地作业中所定义的`alpine` Docker 映像.

### `rules`[](#rules "Permalink")

在 GitLab 12.3 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/27863) .

`rules`关键字是一种设置作业策略的方法，该策略确定是否将作业添加到管道.

将按*顺序*评估单个规则子句的列表，直到一个匹配. 匹配后，根据配置将作业包括在管道中或从管道中排除. 如果包含，则作业还会添加[某些属性](#rules-attributes) .

**注意：** `rules`不能[`only/except`](#onlyexcept-basic)与[`only/except`](#onlyexcept-basic)不能结合使用，因为它是该功能的替代品. 如果尝试执行此操作，则 linter 返回的`key may not be used with rules`错误`key may not be used with rules` .

#### Rules attributes[](#rules-attributes "Permalink")

`rules`允许的作业属性是：

*   [`when`](#when) ：如果未定义，则默认为`when: on_success` .
    *   如果用作`when: delayed` ，则还需要`start_in` .
*   [`allow_failure`](#allow_failure) ：如果未定义，则默认为`allow_failure: false` .

如果一个规则的计算结果为 true，并且`when`具有除`never`以外的任何值`when` ，该作业将包括在管道中.

例如：

```
docker build:
  script: docker build -t my-image:$CI_COMMIT_REF_SLUG .
  rules:
    - if: '$CI_COMMIT_BRANCH  ==  "master"'
      when: delayed
      start_in: '3  hours'
      allow_failure: true 
```

将来可能会将其他作业配置添加到规则中. 如果没有有用的东西，请[打开一个问题](https://gitlab.com/gitlab-org/gitlab/-/issues) .

#### Rules clauses[](#rules-clauses "Permalink")

可用的规则子句为：

| Clause | Description |
| --- | --- |
| [`if`](#rulesif) | 通过评估`if`语句在管道中添加或排除作业. 与[`only:variables`](#onlyvariablesexceptvariables)类似. |
| [`changes`](#ruleschanges) | 根据更改的文件在管道中添加或排除作业. 与[`only:changes`](#onlychangesexceptchanges)相同. |
| [`exists`](#rulesexists) | 根据特定文件的存在在管道中添加或排除作业. |

Rules are evaluated in order until a match is found. If a match is found, the attributes are checked to see if the job should be added to the pipeline. If no attributes are defined, the defaults are:

*   `when: on_success`
*   `allow_failure: false`

作业已添加到管道中：

*   如果规则匹配并且具有以下条件`when: on_success` ， `when: delayed` `when: on_success`或`when: always` .
*   如果没有规则匹配，但最后一个子句为`when: on_success` ， `when: delayed` `when: on_success`或`when: always` （无规则）.

作业未添加到管道：

*   如果没有规则匹配，并且在以下情况下没有独立的条件`when: on_success` ， `when: delayed` `when: on_success`或`when: always` .
*   如果规则匹配，并且具有以下条件`when: never`作为属性.

例如，使用`if`子句严格限制作业运行的时间：

```
job:
  script: "echo  Hello,  Rules!"
  rules:
    - if: '$CI_PIPELINE_SOURCE  ==  "merge_request_event"'
      when: manual
      allow_failure: true
    - if: '$CI_PIPELINE_SOURCE  ==  "schedule"' 
```

在此示例中：

*   如果管道用于合并请求，则第一个规则匹配，并且作业将添加到[合并请求管道](../merge_request_pipelines/index.html) ，其属性为：
    *   `when: manual` （手动工作）
    *   `allow_failure: true` （即使未运行手动作业，也允许管道继续运行）
*   如果管道**不是**用于合并请求的，则第一条规则不匹配，并且第二条规则被评估.
*   如果管道是计划的管道，则第二条规则匹配，并将作业添加到计划的管道. 由于未定义任何属性，因此添加了：
    *   `when: on_success` （默认）
    *   `allow_failure: false` （默认）
*   在**所有其他情况下** ，没有规则匹配，因此该作业**不会**添加到任何其他管道.

另外，您可以定义一组规则以在某些情况下排除作业，但在所有其他情况下运行它们：

```
job:
  script: "echo  Hello,  Rules!"
  rules:
    - if: '$CI_PIPELINE_SOURCE  ==  "merge_request_event"'
      when: never
    - if: '$CI_PIPELINE_SOURCE  ==  "schedule"'
      when: never
    - when: on_success 
```

*   如果管道用于合并请求， **则不**会将作业添加到管道.
*   如果管道是计划的管道， **则不**会将作业添加到管道.
*   在**所有其他情况下** ，将使用以下时间将作业添加到管道中`when: on_success` .

**注意**如果你使用`when: on_success` ， `always` ，或`delayed`作为最终的规则，两个同时进行的管道可能会启动. 推送管道和合并请求管道都可以由同一事件触发（对于打开的合并请求，将其推送到源分支）. 请参阅[`rules`之间](#differences-between-rules-and-onlyexcept)的[重要区别， `only` / `except`](#differences-between-rules-and-onlyexcept)以获取更多详细信息.

#### Differences between `rules` and `only`/`except`[](#differences-between-rules-and-onlyexcept "Permalink")

默认情况下， `only/except`定义的作业不会触发合并请求管道. 您必须`only: merge_requests`明确添加`only: merge_requests` .

用`rules`定义的作业可以触发所有类型的管道. 您不必显式配置每种类型.

例如：

```
job:
  script: "echo  This  creates  double  pipelines!"
  rules:
    - if: '$CUSTOM_VARIABLE  ==  "false"'
      when: never
    - when: always 
```

This job does not run when `$CUSTOM_VARIABLE` is false, but it *does* run in **all** other pipelines, including **both** push (branch) and merge request pipelines. With this configuration, every push to an open merge request’s source branch causes duplicated pipelines. Explicitly allowing both push and merge request pipelines in the same job could have the same effect.

我们建议使用[`workflow: rules`](#workflowrules)来限制允许的管道类型. 仅允许合并请求管道，或仅允许分支管道，可以消除重复的管道. 另外，您也可以使用最终避免重写规则更严格，或`when` （ `always` ， `on_success`或`delayed` ）.

另外，我们不建议在同一管道中将`only/except`作业与`rules`作业混合使用. 它可能不会导致 YAML 错误，但是由于`only/except`和`rules`默认行为不同，因此调试确切的执行行为可能会很复杂.

##### `rules:if`[](#rulesif "Permalink")

`rules:if`子句通过评估简单的`if`语句来确定是否将作业添加到管道. 如果`if`语句为 true，则将作业包括在管道中或从管道中排除. 用简单的英语， `if`规则可以解释为之一：

*   "如果此规则评估为 true，则添加作业"（默认值）.
*   "如果该规则评估为 true，则不要添加作业"（通过添加`when: never` ）.

`rules:if`与`only:variables`略有不同，每个规则仅接受一个表达式字符串，而不是它们的数组. 可以使用`&&`或`||`将要求值的任何表达式集组合为一个表达式. ，并使用[变量匹配语法](../variables/README.html#syntax-of-environment-variable-expressions) .

`if:` clauses are evaluated based on the values of [predefined environment variables](../variables/predefined_variables.html) or [custom environment variables](../variables/README.html#custom-environment-variables).

例如：

```
job:
  script: "echo  Hello,  Rules!"
  rules:
    - if: '$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME  =~  /^feature/  &&  $CI_MERGE_REQUEST_TARGET_BRANCH_NAME  ==  "master"'
      when: always
    - if: '$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME  =~  /^feature/'
      when: manual
      allow_failure: true
    - if: '$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME' # Checking for the presence of a variable is possible 
```

有关确定`when`上班的逻辑的一些详细信息：

*   如果提供的规则都不匹配，则将作业设置为以下`when: never` ，并且不包含在管道中.
*   不带任何条件子句的规则，例如不带`if`或`changes`的`when`或`allow_failure`规则，始终匹配，并且在达到条件时始终使用.
*   If a rule matches and has no `when` defined, the rule uses the `when` defined for the job, which defaults to `on_success` if not defined.
*   您可以定义`when`一次按规则，或在一次作业级别，它适用于所有规则. 你不能混用`when`在作业水平`when`的规则.

对于类似于[`only` / `except`关键字的](#onlyexcept-basic)行为，可以检查`$CI_PIPELINE_SOURCE`变量的值.

| Value | Description |
| --- | --- |
| `push` | 对于由`git push`事件触发的管道，包括分支和标签. |
| `web` | 对于使用 GitLab UI 中的**"运行管道"**按钮创建的**管道** ，请从项目的**CI / CD>"管道"**部分. |
| `trigger` | For pipelines created by using a trigger token. |
| `schedule` | For [scheduled pipelines](../pipelines/schedules.html). |
| `api` | 对于由[管道 API](../../api/pipelines.html#create-a-new-pipeline)触发的[管道](../../api/pipelines.html#create-a-new-pipeline) . |
| `external` | 使用除 GitLab 以外的 CI 服务时. |
| `pipelines` | 对于通过[将 API 与`CI_JOB_TOKEN`一起使用](../triggers/README.html#when-used-with-multi-project-pipelines)创建的多项目管道. |
| `chat` | 对于使用[GitLab ChatOps](../chatops/README.html)命令创建的管道. |
| `webide` | 对于使用[WebIDE](../../user/project/web_ide/index.html)创建的管道. |
| `merge_request_event` | 对于在创建或更新合并请求时创建的管道. 启用[合并请求管道](../merge_request_pipelines/index.html) ， [合并结果管道](../merge_request_pipelines/pipelines_for_merged_results/index.html)和[合并序列所](../merge_request_pipelines/pipelines_for_merged_results/merge_trains/index.html)必需. |
| `external_pull_request_event` | 在 GitHub 上创建或更新外部拉取请求时. 有关[外部拉取请求，](../ci_cd_for_external_repos/index.html#pipelines-for-external-pull-requests)请参见[管道](../ci_cd_for_external_repos/index.html#pipelines-for-external-pull-requests) . |
| `parent_pipeline` | 对于由具有`rules`的[父/子](../parent_child_pipelines.html)管道触发的[管道](../parent_child_pipelines.html) ，请在子管道配置中使用它，以便可以由父管道触发. |

例如：

```
job:
  script: "echo  Hello,  Rules!"
  rules:
    - if: '$CI_PIPELINE_SOURCE  ==  "schedule"'
      when: manual
      allow_failure: true
    - if: '$CI_PIPELINE_SOURCE  ==  "push"' 
```

此示例在以下情况下在计划的管道或推送管道（到分支或标签）中将其作为手动作业运行`when: on_success` （默认）. 不会将作业添加到任何其他管道类型.

另一个例子：

```
job:
  script: "echo  Hello,  Rules!"
  rules:
    - if: '$CI_PIPELINE_SOURCE  ==  "merge_request_event"'
    - if: '$CI_PIPELINE_SOURCE  ==  "schedule"' 
```

本示例将作业作为以下`when: on_success`运行`when: on_success`在[合并请求管道](../merge_request_pipelines/index.html)和计划管道中的`when: on_success`作业. 它不能在任何其他管道类型中运行.

`if`子句的其他常用变量：

*   `if: $CI_COMMIT_TAG` ：是否为标签推送更改.
*   `if: $CI_COMMIT_BRANCH` ：是否将更改推送到任何分支.
*   `if: '$CI_COMMIT_BRANCH == "master"'` ：如果将更改推送到`master` .
*   `if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'` ：如果将更改推送到默认分支（通常是`master` ）. 如果在可能具有不同默认分支的多个项目中重用同一配置，则很有用.
*   `if: '$CI_COMMIT_BRANCH =~ /regex-expression/'` ：如果 commit 分支与正则表达式匹配.
*   `if: '$CUSTOM_VARIABLE !~ /regex-expression/'` ：如果[自定义变量](../variables/README.html#custom-environment-variables) `CUSTOM_VARIABLE`与正则表达式**不**匹配.
*   `if: '$CUSTOM_VARIABLE == "value1"'` ：如果自定义变量`CUSTOM_VARIABLE`恰好是`value1` .

##### `rules:changes`[](#ruleschanges "Permalink")

要确定是否应将作业添加到管道，请使用`rules: changes`子句检查由 Git push 事件更改的文件.

`rules: changes`工作方式与[`only: changes`和`except: changes`](#onlychangesexceptchanges) ，接受路径数组. 同样，如果没有 Git 推送事件，则始终返回 true. 它仅应用于分支管道或合并请求管道.

例如：

```
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE  ==  "merge_request_event"'

docker build:
  script: docker build -t my-image:$CI_COMMIT_REF_SLUG .
  rules:
    - changes:
        - Dockerfile
      when: manual
      allow_failure: true 
```

在此示例中：

*   [`workflow: rules`](#workflowrules)仅允许用于所有作业的合并请求的管道.
*   如果`Dockerfile`已更改，则将作业作为手动作业添加到管道中，并允许管道继续运行，即使未触发该作业（ `allow_failure: true` ）.
*   如果`Dockerfile`尚未更改，请不要将作业添加到任何管道（与`when: never`相同）.

##### `rules:exists`[](#rulesexists "Permalink")

在 GitLab 12.4 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/24021) .

`exists` accepts an array of paths and will match if any of these paths exist as files in the repository.

例如：

```
job:
  script: docker build -t my-image:$CI_COMMIT_REF_SLUG .
  rules:
    - exists:
        - Dockerfile 
```

您还可以使用全局模式来匹配存储库中任何目录中的多个文件.

例如：

```
job:
  script: bundle exec rspec
  rules:
    - exists:
        - spec/**.rb 
```

**注意：**出于性能原因，使用`exists`与模式限制为 10000 个检查. 第 10000 次检查后，带有图案化球形的规则将始终匹配.

##### `rules:allow_failure`[](#rulesallow_failure "Permalink")

在 GitLab 12.8 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/30235) .

您可以在`rules:`使用[`allow_failure: true`](#allow_failure) `rules:`在不停止管道本身的情况下允许作业失败或手动作业等待操作. 所有使用`rules:`作业`rules:`默认为`allow_failure: false`如果`allow_failure:` ， `allow_failure: false` .

规则级`rules:allow_failure`选项将覆盖作业级[`allow_failure`](#allow_failure)选项，并且仅在特定规则触发作业时才应用.

```
job:
  script: "echo  Hello,  Rules!"
  rules:
    - if: '$CI_MERGE_REQUEST_TARGET_BRANCH_NAME  ==  "master"'
      when: manual
      allow_failure: true 
```

在此示例中，如果第一个规则匹配，则作业将具有以下`when: manual`和`allow_failure: true` .

#### Complex rule clauses[](#complex-rule-clauses "Permalink")

要使`if` ， `changes`和`exists`子句与 AND 结合在一起，请在同一规则中使用它们.

在以下示例中：

*   如果`Dockerfile`或`Dockerfile` `docker/scripts/`任何文件已更改并且`$VAR == "string value"`我们将手动运行作业.
*   否则，该作业将不会包含在管道中.

```
docker build:
  script: docker build -t my-image:$CI_COMMIT_REF_SLUG .
  rules:
    - if: '$VAR  ==  "string  value"'
      changes: # Will include the job and set to when:manual if any of the follow paths match a modified file.
        - Dockerfile
        - docker/scripts/*
      when: manual
  # - when: never would be redundant here, this is implied any time rules are listed. 
```

当前`only`可用于/ `except`关键字（例如`branches`或`refs`在`rules`尚不可用，因为在这种情况下，它们的用法和行为被单独考虑. 我们将在[史诗](https://gitlab.com/groups/gitlab-org/-/epics/2783)中讨论未来的关键字改进， [以改进`rules`](https://gitlab.com/groups/gitlab-org/-/epics/2783) ，任何人都可以添加建议或请求.

### `only`/`except` (basic)[](#onlyexcept-basic "Permalink")

**注意：** [`rules`](#rules)语法是一种改进的功能更强大的解决方案，用于定义作业何时运行或不运行. 考虑使用`rules`而不是`only/except`来最大程度地利用管道.

`only`和`except`是用于设置作业策略以限制创建作业时间的两个参数：

1.  `only` defines the names of branches and tags for which the job will run.
2.  `except`定义将**不**运行作业的分支和标签的名称.

有一些适用于作业策略的规则：

*   `only`且`except` . 如果作业规范中同时定义了`only`和`except` ，则 ref 将被`only`和`except`过滤.
*   `only`且`except`允许使用正则表达式（ [受支持的 regexp 语法](#supported-onlyexcept-regexp-syntax) ）.
*   `only`且`except`允许指定存储库路径以过滤派生作业.

此外， `only`和`except`允许使用特殊关键字：

| **Value** | **Description** |
| --- | --- |
| `branches` | 当管道的 Git 参考是分支时. |
| `tags` | 当管道的 Git 参考是标签时. |
| `api` | 对于由[管道 API](../../api/pipelines.html#create-a-new-pipeline)触发的[管道](../../api/pipelines.html#create-a-new-pipeline) . |
| `external` | 使用除 GitLab 以外的 CI 服务时. |
| `pipelines` | 对于通过将 API 与`CI_JOB_TOKEN`一起使用创建的多项目管道. |
| `pushes` | 对于由`git push`事件触发的管道，包括分支和标签. |
| `schedules` | For [scheduled pipelines](../pipelines/schedules.html). |
| `triggers` | 对于使用触发令牌创建的管道. |
| `web` | 对于使用 GitLab UI 中的**"运行管道"**按钮创建的**管道** ，请从项目的**CI / CD>"管道"**部分. |
| `merge_requests` | 对于在创建或更新合并请求时创建的管道. 启用[合并请求管道](../merge_request_pipelines/index.html) ， [合并结果管道](../merge_request_pipelines/pipelines_for_merged_results/index.html)和[合并序列](../merge_request_pipelines/pipelines_for_merged_results/merge_trains/index.html) . |
| `external_pull_requests` | 在 GitHub 上创建或更新[外部拉取请求时](../ci_cd_for_external_repos/index.html#pipelines-for-external-pull-requests) （有关[外部拉取请求，](../ci_cd_for_external_repos/index.html#pipelines-for-external-pull-requests)请参见[管道](../ci_cd_for_external_repos/index.html#pipelines-for-external-pull-requests) ）. |
| `chat` | 对于使用[GitLab ChatOps](../chatops/README.html)命令创建的管道. |

在下面的例子中， `job`将只运行了与裁判开始`issue-` ，而所有分支机构将被忽略：

```
job:
  # use regexp
  only:
    - /^issue-.*$/
  # use special keyword
  except:
    - branches 
```

模式匹配默认情况下区分大小写. 使用`i`标志修饰符，例如`/pattern/i` ，使模式不区分大小写：

```
job:
  # use regexp
  only:
    - /^issue-.*$/i
  # use special keyword
  except:
    - branches 
```

在此示例中， `job`仅对标记了标签的引用运行，或者如果通过 API 触发器或[管道时间表](../pipelines/schedules.html)明确请求构建，则`job`将运行：

```
job:
  # use special keywords
  only:
    - tags
    - triggers
    - schedules 
```

存储库路径可用于仅对父存储库执行作业，而不能用于派生：

```
job:
  only:
    - branches@gitlab-org/gitlab
  except:
    - master@gitlab-org/gitlab
    - /^release/.*$/@gitlab-org/gitlab 
```

上面的示例将为`gitlab-org/gitlab`上的所有分支运行`job` ，但`master`和名称以`release/` `gitlab-org/gitlab`分支除外.

如果作业没有`only`规则，则默认情况下`only: ['branches', 'tags']` . 如果没有`except`规则，则为空.

例如，

```
job:
  script: echo 'test' 
```

转换为：

```
job:
  script: echo 'test'
  only: ['branches', 'tags'] 
```

#### Regular expressions[](#regular-expressions "Permalink")

因为`@`用于表示 ref 的存储库路径的开头，所以匹配正则表达式中包含`@`字符的 ref 名称需要使用十六进制字符代码匹配`\x40` .

正则表达式只能匹配标签或分支名称. 如果给定存储库路径，则始终在字面上匹配.

如果必须使用正则表达式来匹配标记或分支名称，则模式的整个 ref 名称部分必须是正则表达式，并且必须用`/`括起来. （在结束符`/`之后附加正则表达式标志.）因此`issue-/.*/`不能匹配所有以`issue-`开头的标记名或分支名.

**提示**使用定位符`^`和`$`避免正则表达式仅匹配标记名称或分支名称的子字符串. 例如， `/^issue-/` `/^issue-.*$/` `/^issue-/`等效于`/^issue-/` `/^issue-.*$/` `/^issue-/` ，而只是`/issue/`也会匹配一个名为`/^issue-.*$/` `severe-issues`的分支.

#### Supported `only`/`except` regexp syntax[](#supported-onlyexcept-regexp-syntax "Permalink")

**警告：**这是 GitLab 11.9.4 引入的重大更改.

在 GitLab 11.9.4 中，GitLab 开始内部将`only`用于参数（参数`except` regexp 转换为[RE2](https://github.com/google/re2/wiki/Syntax) .

这意味着仅支持[Ruby Regexp](https://ruby-doc.org/core/Regexp.html)提供的功能子集. 由于计算复杂性， [RE2](https://github.com/google/re2/wiki/Syntax)限制了所提供的功能集，这意味着某些功能在 GitLab 11.9.4 中变得不可用. 例如，负面的前瞻.

For GitLab versions from 11.9.7 and up to GitLab 12.0, GitLab provides a feature flag that can be enabled by administrators that allows users to use unsafe regexp syntax. This brings compatibility with previously allowed syntax version and allows users to gracefully migrate to the new syntax.

```
Feature.enable(:allow_unsafe_ruby_regexp) 
```

### `only`/`except` (advanced)[](#onlyexcept-advanced "Permalink")

**警告：**这是*Alpha 版*功能，如有更改，恕不另行通知！

GitLab 支持简单策略和复杂策略，因此可以使用数组和哈希配置方案.

有四个键可用：

*   `refs`
*   `variables`
*   `changes`
*   `kubernetes`

如果`only`或`except`下使用多个键，则这些键将被视为单个联合表达式. 那是：

*   `only:`表示"如果所有条件都匹配，则包括此作业".
*   `except:`表示"如果任何条件匹配，则排除此工作".

使用`only` ，各个键在逻辑上由 AND 联接：

> （任何参考）AND（任何变量）AND（任何变化）AND（如果 Kubernetes 是活动的）

在下面的示例中， `only`在满足以下**所有条件** `only`创建`test`作业：

*   该管道已被[调度](../../user/project/pipelines/schedules.html) **或**正在`master`管道运行.
*   `variables`关键字匹配.
*   `kubernetes`服务在项目上处于活动状态.

```
test:
  script: npm run test
  only:
    refs:
      - master
      - schedules
    variables:
      - $CI_COMMIT_MESSAGE =~ /run-end-to-end-tests/
    kubernetes: active 
```

`except`被实现为对此完整表达式的否定：

> NOT（（任何参考）AND（任何变量）AND（任何变化）AND（如果 Kubernetes 处于活动状态））

This means the keys are treated as if joined by an OR. This relationship could be described as:

> （任何参考）或（任何变量）或（任何变化）或（如果 Kubernetes 处于活动状态）

在以下示例中，如果满足以下**任一条件** ，则**不会**创建`test`作业：

*   该管道的运行`master` .
*   存储库的根目录中的`README.md`文件进行了更改.

```
test:
  script: npm run test
  except:
    refs:
      - master
    changes:
      - "README.md" 
```

#### `only:refs`/`except:refs`[](#onlyrefsexceptrefs "Permalink")

GitLab 10.0 中引入的`refs`策略.

`refs`策略可以采用与[简化的 only / except 配置](#onlyexcept-basic)相同的值.

在下面的示例中，仅在`master`分支[计划](../pipelines/schedules.html)或运行管道时才创建`deploy`作业：

```
deploy:
  only:
    refs:
      - master
      - schedules 
```

#### `only:kubernetes`/`except:kubernetes`[](#onlykubernetesexceptkubernetes "Permalink")

GitLab 10.0 中引入的`kubernetes`策略.

The `kubernetes` strategy accepts only the `active` keyword.

在下面的示例中，仅当项目中的 Kubernetes 服务处于活动状态时，才将创建`deploy`作业：

```
deploy:
  only:
    kubernetes: active 
```

#### `only:variables`/`except:variables`[](#onlyvariablesexceptvariables "Permalink")

GitLab 10.7 中引入了`variables`策略.

`variables`关键字用于定义变量表达式. 换句话说，您可以使用预定义变量/项目/组或环境范围的变量来定义 GitLab 将要评估的表达式，以决定是否应创建作业.

使用变量表达式的示例：

```
deploy:
  script: cap staging deploy
  only:
    refs:
      - branches
    variables:
      - $RELEASE == "staging"
      - $STAGING 
```

另一个用例是根据提交消息排除作业：

```
end-to-end:
  script: rake test:end-to-end
  except:
    variables:
      - $CI_COMMIT_MESSAGE =~ /skip-end-to-end-tests/ 
```

了解有关[变量表达式的](../variables/README.html#environment-variables-expressions)更多信息.

#### `only:changes`/`except:changes`[](#onlychangesexceptchanges "Permalink")

`changes` GitLab 11.4 中[引入的](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/19232)策略.

利用`changes`与关键字`only`或`except`能够基于通过推送操作事件被修改的文件定义，如果一个工作应该被创建.

这意味着`only:changes`策略对以下情况的管道很有用：

*   `$CI_PIPELINE_SOURCE == 'push'`
*   `$CI_PIPELINE_SOURCE == 'merge_request_event'`
*   `$CI_PIPELINE_SOURCE == 'external_pull_request_event'`

如果没有 Git 推送事件（例如，对于具有[上述三个之外的源的](../variables/predefined_variables.html)管道），则`changes`无法确定给定文件是新文件还是旧文件，并且始终返回 true.

`only: changes`使用的一个基本示例`only: changes` ：

```
docker build:
  script: docker build -t my-image:$CI_COMMIT_REF_SLUG .
  only:
    changes:
      - Dockerfile
      - docker/scripts/*
      - dockerfiles/**/*
      - more_scripts/*.{rb,py,sh} 
```

在上述场景中，当将提交推送到 GitLab 中的现有分支时，它会创建并触发`docker build`作业，只要其中一个提交包含对以下任何一项的更改：

*   The `Dockerfile` file.
*   `docker/scripts/`目录中的任何文件.
*   `dockerfiles`目录中的任何文件和子目录.
*   `more_scripts`目录中具有`rb` ， `py` ， `sh`扩展名的`more_scripts`文件.

**警告：**如果`only:changes`使用`only:changes` [仅允许在管道成功的情况下合并合并请求，则](../../user/project/merge_requests/merge_when_pipeline_succeeds.html#only-allow-merge-requests-to-be-merged-if-the-pipeline-succeeds)如果不[同时使用`only:merge_requests`](#using-onlychanges-with-pipelines-for-merge-requests)则可能导致不良行为.

您还可以使用 glob 模式来匹配存储库的根目录或存储库内*任何*目录中的多个文件，但是它们必须用双引号引起来，否则 GitLab 将无法解析`.gitlab-ci.yml` . 例如：

```
test:
  script: npm run test
  only:
    changes:
      - "*.json"
      - "**/*.sql" 
```

如果在存储库根目录中任何扩展名为`.md`文件中检测到更改，以下示例将跳过`build`作业：

```
build:
  script: npm run build
  except:
    changes:
      - "*.md" 
```

**警告：**当[将此功能与*没有*合并请求管道的新分支或标记一起使用](#using-onlychanges-without-pipelines-for-merge-requests)时，需要注意一些要点.**警告：**在[计划的管道上使用此功能](#using-onlychanges-with-scheduled-pipelines)时，需要注意一些要点.

##### Using `only:changes` with pipelines for merge requests[](#using-onlychanges-with-pipelines-for-merge-requests "Permalink")

使用[用于合并请求的管道，](../merge_request_pipelines/index.html)可以根据在合并请求中修改的文件来定义要创建的作业.

为了推断源分支的正确基础 SHA，建议`only: [merge_requests]`将此关键字与`only: [merge_requests]` . 这样，可以从任何进一步的提交中正确计算出文件差异，因此可以在管道中正确测试合并请求中的所有更改.

例如：

```
docker build service one:
  script: docker build -t my-service-one-image:$CI_COMMIT_REF_SLUG .
  only:
    refs:
      - merge_requests
    changes:
      - Dockerfile
      - service-one/**/* 
```

在上述情况下，如果创建或更新了合并请求，从而更改了`service-one`目录中的文件或`Dockerfile` ，则 GitLab 将创建并触发`Dockerfile` `docker build service one`作业.

Note that if [pipelines for merge requests](../merge_request_pipelines/index.html) is combined with `only: [change]`, but `only: [merge_requests]` is omitted, there could be unwanted behavior.

例如：

```
docker build service one:
  script: docker build -t my-service-one-image:$CI_COMMIT_REF_SLUG .
  only:
    changes:
      - Dockerfile
      - service-one/**/* 
```

在上面的示例中，管道可能由于对`service-one/**/*`的文件的更改而失败. 然后可以推送更高版本的提交，该提交不包括对该文件的任何更改，但包括对`Dockerfile`更改，并且该管道可以通过，因为它仅测试对`Dockerfile`的更改. GitLab 会检查**最近** **通过的** **管道** ，并且将合并请求显示为可合并，尽管较早的管道失败是由于尚未更正的更改引起的.

使用此配置时，必须注意检查最新的管道是否正确地纠正了先前管道的任何故障.

##### Using `only:changes` without pipelines for merge requests[](#using-onlychanges-without-pipelines-for-merge-requests "Permalink")

如果没有[用于合并请求的](../merge_request_pipelines/index.html)管道，则管道将在与合并请求没有明确关联的分支或标签上运行. 在这种情况下，将使用先前的 SHA 来计算 diff，这等效于`git diff HEAD~` . 这可能会导致某些意外行为，包括：

*   When pushing a new branch or a new tag to GitLab, the policy always evaluates to true.
*   推送新提交时，更改的文件将使用先前的提交作为基础 SHA 进行计算.

##### Using `only:changes` with scheduled pipelines[](#using-onlychanges-with-scheduled-pipelines "Permalink")

`only:changes`在[Scheduled 管道中](../pipelines/schedules.html)始终评估为" true". 当计划的管道运行时，所有文件都被视为"已更改".

### `needs`[](#needs "Permalink")

版本历史

*   在 GitLab 12.2 中[引入](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/47063) .
*   在 GitLab 12.3 中， `needs`阵列中的最大作业数从 5 个增加到 50 个.
*   在 GitLab 12.8 中[引入的](https://gitlab.com/gitlab-org/gitlab/-/issues/30631) `needs: []`使作业立即开始.

`needs:`关键字可无序执行作业，使您可以在`.gitlab-ci.yml`实现有[向无环图](../directed_acyclic_graph/index.html) .

这样，您无需等待阶段顺序即可运行某些作业，而无需等待其他任务，因此您可以让多个阶段同时运行.

让我们考虑以下示例：

```
linux:build:
  stage: build

mac:build:
  stage: build

lint:
  stage: test
  needs: []

linux:rspec:
  stage: test
  needs: ["linux:build"]

linux:rubocop:
  stage: test
  needs: ["linux:build"]

mac:rspec:
  stage: test
  needs: ["mac:build"]

mac:rubocop:
  stage: test
  needs: ["mac:build"]

production:
  stage: deploy 
```

本示例创建四个执行路径：

*   棉短绒：在`lint`作业将立即运行，而无需等待`build`阶段完成，因为它没有需求（ `needs: []`

*   Linux 路径： `linux:build`作业完成后，将立即运行`linux:rspec`和`linux:rubocop`作业，而无需等待`mac:build`完成.

*   macOS 路径： `mac:build`作业完成后，将立即运行`mac:rspec`和`mac:rubocop`作业，而无需等待`linux:build`完成.

*   `production`作业将在所有先前的作业完成后立即执行； 在这种情况下： `linux:build` ， `linux:rspec` ， `linux:rubocop` ， `mac:build` ， `mac:rspec` ， `mac:rubocop` .

#### Requirements and limitations[](#requirements-and-limitations "Permalink")

*   如果`needs:`设置为指向`only/except`因`only/except`规则而未实例化的作业，或者不存在，则创建管道时会出现 YAML 错误.
*   `needs:`数组中单个作业可能需要的最大作业数是有限的：
    *   对于 GitLab.com，限制为十个. 有关更多信息，请参见[基础结构问题](https://gitlab.com/gitlab-com/gl-infra/infrastructure/-/issues/7541) .
    *   对于自我管理的实例，限制为：
        *   10，如果`ci_dag_limit_needs`功能标志已启用（默认）.
        *   50，如果`ci_dag_limit_needs`功能标记被禁用.
*   如果`needs:`是指标记为" `parallel:`的作业. 当前作业将取决于创建的所有并行作业.
*   `needs:`类似于`dependencies:`它需要使用之前阶段的作业，这意味着不可能创建循环依赖关系. 在当前阶段也不可能依赖于工作，但是[已计划了](https://gitlab.com/gitlab-org/gitlab/-/issues/30632)支持.
*   与上述相关，必须为所有具有关键字`needs:`或由一个人引用的作业明确定义阶段.

##### Changing the `needs:` job limit[](#changing-the-needs-job-limit "Permalink")

可以在`needs:`定义的最大作业数`needs:`默认为 10，但可以通过功能标志更改为 50\. 要将限制更改为 50，请[启动 Rails 控制台会话](../../administration/troubleshooting/debug.html#starting-a-rails-console-session)并运行：

```
Feature::disable(:ci_dag_limit_needs) 
```

要将其设置回 10，请运行相反的命令：

```
Feature::enable(:ci_dag_limit_needs) 
```

#### Artifact downloads with `needs`[](#artifact-downloads-with-needs "Permalink")

[介绍](https://gitlab.com/gitlab-org/gitlab/-/issues/14311)在 GitLab v12.6.

在使用`needs` ，可通过`artifacts: true` （默认）或`artifacts: false`来控制工件下载.

从 GitLab 12.6 开始，您不能将[`dependencies`](#dependencies)关键字与控制作业中工件下载的`needs`结合使用. `dependencies`在不使用`needs`作业中仍然有效.

在以下示例中， `rspec`作业将下载`build_job`工件，而`rubocop`作业则不会：

```
build_job:
  stage: build
  artifacts:
    paths:
      - binaries/

rspec:
  stage: test
  needs:
    - job: build_job
      artifacts: true

rubocop:
  stage: test
  needs:
    - job: build_job
      artifacts: false 
```

另外，在下面的三个语法示例中， `rspec`作业将从所有三个`build_jobs`下载工件，因为`artifacts`对于`build_job_1`是 true，并且对于`build_job_2`和`build_job_3`都**默认**为 true.

```
rspec:
  needs:
    - job: build_job_1
      artifacts: true
    - job: build_job_2
    - build_job_3 
```

#### Cross project artifact downloads with `needs`[](#cross-project-artifact-downloads-with-needs-premium "Permalink")

[介绍](https://gitlab.com/gitlab-org/gitlab/-/issues/14311)在 GitLab v12.7.

`needs`可用于从[同一项目中其他 ref](#artifact-downloads-between-pipelines-in-the-same-project)或不同项目中的管道上的多达五个作业的工件中下载工件：

```
build_job:
  stage: build
  script:
    - ls -lhR
  needs:
    - project: group/project-name
      job: build-1
      ref: master
      artifacts: true 
```

`build_job`将从`group/project-name`项目的`master`分支上的最新成功`build-1`作业中下载工件.

##### Artifact downloads between pipelines in the same project[](#artifact-downloads-between-pipelines-in-the-same-project "Permalink")

通过将`project`关键字设置为当前项目的名称，并指定引用，可以使用`needs`从当前项目的不同管道中下载工件. 在下面的示例中， `build_job`将使用`other-ref` ref 下载最新成功的`build-1`作业的工件：

```
build_job:
  stage: build
  script:
    - ls -lhR
  needs:
    - project: group/same-project-name
      job: build-1
      ref: other-ref
      artifacts: true 
```

**注意：**不支持从[`parallel:`](#parallel)运行的作业中下载工件[`parallel:`](#parallel)

### `tags`[](#tags "Permalink")

`tags`用于从允许运行该项目的所有 Runner 列表中选择特定的 Runner.

在 Runner 的注册过程中，您可以指定 Runner 的标签，例如`ruby` ， `postgres` ， `development` .

`tags`可让您为具有指定标签的跑步者运行作业：

```
job:
  tags:
    - ruby
    - postgres 
```

上面的规范将确保`job`由同时定义了`ruby`和`postgres`标签的 Runner 构建.

标签也是在不同平台上运行不同作业的好方法，例如，给定带有`osx`标签的 OS X Runner 和带有`windows`标签的 Windows Runner，以下作业将在各自的平台上运行：

```
windows job:
  stage:
    - build
  tags:
    - windows
  script:
    - echo Hello, %USERNAME%!

osx job:
  stage:
    - build
  tags:
    - osx
  script:
    - echo "Hello, $USER!" 
```

### `allow_failure`[](#allow_failure "Permalink")

`allow_failure`允许作业失败，而不会影响其余 CI 套件. 默认值是`false` ，除了使用`when: manual`语法的[手动](#whenmanual)作业之外，除非使用[`rules:`](#rules)语法，否则所有作业默认为 false， *包括* `when: manual`作业.

启用后，如果作业失败，该作业将在用户界面中显示橙色警告. 但是，管道的逻辑流程将认为作业成功/通过，并且不会被阻塞.

假设所有其他作业均成功，则该作业的阶段及其管道将显示相同的橙色警告. 但是，关联的提交将被标记为"通过"，而不会发出警告.

在下面的示例中， `job1`和`job2`将并行运行，但是如果`job1`失败，它不会停止下一阶段的运行，因为它标记有`allow_failure: true` ：

```
job1:
  stage: test
  script:
    - execute_script_that_will_fail
  allow_failure: true

job2:
  stage: test
  script:
    - execute_script_that_will_succeed

job3:
  stage: deploy
  script:
    - deploy_to_staging 
```

### `when`[](#when "Permalink")

`when`用于实现在发生故障或发生故障时运行的作业.

`when`可以被设置为以下值中的一个：

1.  `on_success`仅在先前阶段中的所有作业都成功（或因为标记为`allow_failure`而被视为成功）时才执行作业. 这是默认值.
2.  `on_failure`仅在`on_failure`中的至少一项作业失败时才执行作业.
3.  `always` -执行作业，而不管先前阶段的作业状态如何.
4.  `manual` -手动执行作业（在 GitLab 8.10 中已添加）. 在下面阅读有关[手动操作的信息](#whenmanual) .
5.  `delayed` -一定时间后执行作业（在 GitLab 11.14 中已添加）. 在下面阅读有关[延迟动作的信息](#whendelayed) .

For example:

```
stages:
  - build
  - cleanup_build
  - test
  - deploy
  - cleanup

build_job:
  stage: build
  script:
    - make build

cleanup_build_job:
  stage: cleanup_build
  script:
    - cleanup build when failed
  when: on_failure

test_job:
  stage: test
  script:
    - make test

deploy_job:
  stage: deploy
  script:
    - make deploy
  when: manual

cleanup_job:
  stage: cleanup
  script:
    - cleanup after jobs
  when: always 
```

上面的脚本将：

1.  仅当`build_job`失败时才执行`cleanup_build_job` .
2.  无论成功与失败，始终执行`cleanup_job`作为管道的最后一步.
3.  允许您从 GitLab 的 UI 手动执行`deploy_job` .

#### `when:manual`[](#whenmanual "Permalink")

版本历史

*   在 GitLab 8.10 中引入.
*   在 GitLab 9.0 中引入了阻止手动操作.
*   GitLab 9.2 中引入了受保护的操作.

手动操作是一种特殊类型的作业，不会自动执行，需要用户明确启动. 手动操作的示例用法是部署到生产环境. 可以从管道，作业，环境和部署视图开始手动操作. 在[环境文档中](../environments/index.html#configuring-manual-deployments)阅读更多[内容](../environments/index.html#configuring-manual-deployments) .

手动操作可以是可选的或阻止的. 阻止手动操作将在定义此操作的阶段阻止管道的执行.当有人通过单击*播放*按钮执行阻止手动操作时，可以恢复管道的执行.

当管道被阻塞时，如果设置了"管道成功时合并"，则不会被合并. 阻塞的管道也确实有一种特殊的状态，称为*手动* . 使用`when:manual`语法`when:manual` ，默认情况下手动操作是非阻塞的. 如果要进行手动操作阻止，则必须在`.gitlab-ci.yml`的作业定义中添加`allow_failure: false` .

可选的手动操作具有`allow_failure: true`默认情况下设置为`allow_failure: true` ，并且它们的状态不影响总体管道状态. 因此，如果手动操作失败，则管道最终将成功.

**注意：**使用[`rules:`](#rules) ， `allow_failure`默认为`false` ，包括手动作业.

手动操作被视为写操作，因此当用户想要触发操作时，将使用[受保护分支的](../../user/project/protected_branches.html)权限. 换句话说，为了触发分配给正在为其运行管道的分支的手动操作，用户需要具有合并到该分支的能力. 可以使用受保护的环境来更严格地[保护手动部署](#protecting-manual-jobs-premium) ，以防止未经授权的用户运行.

**注意：同时**使用`when:manual`和`trigger`导致错误`jobs:#{job-name} when should be on_success, on_failure or always` ，因为`when:manual`阻止使用触发器.

##### Protecting manual jobs[](#protecting-manual-jobs-premium "Permalink")

可以使用[受保护的环境](../environments/protected_environments.html)来定义授权运行手动作业的用户的精确列表. 通过仅允许与受保护环境关联的用户触发手动作业，可以实现一些特殊用例，例如：

*   更精确地限制可以部署到环境的人员.
*   使管道能够被阻塞，直到获得批准的用户"批准"为止.

为此，您必须：

1.  为作业添加`environment` . 例如：

    ```
    deploy_prod:
      stage: deploy
      script:
        - echo "Deploy to production server"
      environment:
        name: production
        url: https://example.com
      when: manual
      only:
        - master 
    ```

2.  在" [受保护的环境"设置中](../environments/protected_environments.html#protecting-environments) ，选择环境（上面的示例中为`production` ），然后将被授权触发手动作业的用户，角色或组添加到" **允许部署"**列表中. 只有该列表中的人员以及始终能够使用受保护环境的 GitLab 管理员才能触发此手动作业.

此外，如果通过添加`allow_failure: false`将手动作业定义为阻塞，则直到触发手动作业后，管道的下`allow_failure: false`才会运行. 这可以用作一种方法，使定义的用户列表可以通过触发阻止的手动作业来"批准"后续的管道阶段.

#### `when:delayed`[](#whendelayed "Permalink")

在 GitLab 11.4 中[引入](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/51352) .

延迟的作业用于在一定时间后执行脚本. 如果要避免作业立即进入`pending`状态，此功能很有用.

您可以使用`start_in`键设置时间段. 除非提供了单位，否则`start_in`键的值是以秒为单位的经过时间. `start_in`键必须小于或等于一周. 有效值的示例包括：

*   `'5'`
*   `10 seconds`
*   `30 minutes`
*   `1 day`
*   `1 week`

当阶段中有延迟的工作时，直到延迟的工作完成，管道才能继续进行. 这意味着该关键字也可以用于在不同阶段之间插入延迟.

上一阶段完成后，延迟作业的计时器立即启动. 与其他类型的作业类似，延迟的作业计时器不会启动，除非前一个阶段通过.

以下示例创建一个名为`timed rollout 10%`的作业，该作业在上一阶段完成后 30 分钟执行：

```
timed rollout 10%:
  stage: deploy
  script: echo 'Rolling out 10% ...'
  when: delayed
  start_in: 30 minutes 
```

您可以通过单击"停止"来停止延迟作业的活动计时器. （ **计划外** ）按钮. 除非您手动执行该作业，否则以后将永远不会执行该作业.

您可以通过单击" **播放"**按钮立即开始延迟的作业. GitLab Runner 将很快开始您的工作并开始工作.

### `environment`[](#environment "Permalink")

版本历史

*   在 GitLab 8.9 中引入.
*   您可以阅读有关环境的更多信息，并在[有关环境](../environments/index.html)的[文档中](../environments/index.html)找到更多示例.

`environment`用于定义作业部署到特定环境. 如果指定了`environment` ，但不存在该名称下的环境，则将自动创建一个新环境.

以最简单的形式，可以将`environment`关键字定义为：

```
deploy to production:
  stage: deploy
  script: git push production HEAD:master
  environment: production 
```

在上面的示例中，将`deploy to production`作业标记为正在部署到`production`环境.

#### `environment:name`[](#environmentname "Permalink")

版本历史

*   在 GitLab 8.11 中引入.
*   在 GitLab 8.11 之前，环境的名称可以定义为类似于`environment: production`的字符串`environment: production` . 现在推荐的方法是在`name`关键字下定义它.
*   `name`参数可以使用任何已定义的 CI 变量，包括预定义的安全变量和`.gitlab-ci.yml` [`variables`](#variables) . 但是，您不能使用`script`下定义的变量.

`environment`名称可以包含：

*   letters
*   digits
*   spaces
*   `-`
*   `_`
*   `/`
*   `$`
*   `{`
*   `}`

通用名称是`qa` ， `staging`和`production` ，但是您可以使用与您的工作流程兼容的任何名称.

除了在`environment`关键字之后直接定义环境名称之外，还可以将其定义为单独的值. 为此，请在`environment`下使用`name`关键字：

```
deploy to production:
  stage: deploy
  script: git push production HEAD:master
  environment:
    name: production 
```

#### `environment:url`[](#environmenturl "Permalink")

版本历史

*   在 GitLab 8.11 中引入.
*   在 GitLab 8.11 之前，只能在 GitLab 的 UI 中添加 URL. 现在推荐的方法是在`.gitlab-ci.yml`定义它.
*   `url`参数可以使用任何已定义的 CI 变量，包括预定义的安全变量和`.gitlab-ci.yml` [`variables`](#variables) . 但是，您不能使用`script`下定义的变量.

这是一个可选值，设置该值时，它将在 GitLab 中的不同位置显示按钮，单击这些按钮会将您带到定义的 URL.

在下面的示例中，如果作业成功完成，它将在合并请求和环境/部署页面中创建按钮，这些页面将指向`https://prod.example.com` .

```
deploy to production:
  stage: deploy
  script: git push production HEAD:master
  environment:
    name: production
    url: https://prod.example.com 
```

#### `environment:on_stop`[](#environmenton_stop "Permalink")

版本历史

*   在 GitLab 8.13 中[引入](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/22191) .
*   从 GitLab 8.14 开始，当您具有定义了停止动作的环境时，当删除关联的分支时，GitLab 将自动触发停止动作.

可以通过在`on_stop`下定义的`on_stop`关键字来实现关闭（停止） `environment` . 它声明运行另一个作业以关闭环境.

请阅读`environment:action`部分以获取示例.

#### `environment:action`[](#environmentaction "Permalink")

在 GitLab 8.13 中[引入](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/22191) .

`action`关键字将与`on_stop`结合使用，并在调用关闭环境的作业中定义.

举个例子：

```
review_app:
  stage: deploy
  script: make deploy-app
  environment:
    name: review/$CI_COMMIT_REF_NAME
    url: https://$CI_ENVIRONMENT_SLUG.example.com
    on_stop: stop_review_app

stop_review_app:
  stage: deploy
  variables:
    GIT_STRATEGY: none
  script: make delete-app
  when: manual
  environment:
    name: review/$CI_COMMIT_REF_NAME
    action: stop 
```

在上面的例子中，我们建立了`review_app`工作部署到`review`环境，我们还定义了一个新`stop_review_app`下工作`on_stop` . 一旦`review_app`作业成功完成，就会触发`stop_review_app`根据什么下定义的作业`when` . 在这种情况下，我们将其设置为`manual`因此需要通过 GitLab 的 Web 界面进行[手动操作](#whenmanual)才能运行.

同样在该示例中， `GIT_STRATEGY`设置为`none`以便当[自动触发](../environments/index.html#automatically-stopping-an-environment) `stop_review_app`作业时，删除分支后，GitLab Runner 将不会尝试检出代码.

**注意：**上面的示例覆盖了全局变量. 如果停止环境作业依赖于全局变量，则可以在设置`GIT_STRATEGY`时使用[锚变量](#yaml-anchors-for-variables)来更改它，而不覆盖全局变量.

**需要** `stop_review_app`作业定义以下关键字：

*   `when` - [reference](#when)
*   `environment:name`
*   `environment:action`

此外，两个作业都应具有匹配的[`rules`](../yaml/README.html#onlyexcept-basic)或[`only/except`](../yaml/README.html#onlyexcept-basic)配置[`only/except`](../yaml/README.html#onlyexcept-basic) . 在上面的示例中，如果配置不同，则`stop_review_app`作业可能未包含在所有包含`review_app`作业的管道中，并且将无法触发该`action: stop`以自动停止环境.

#### `environment:auto_stop_in`[](#environmentauto_stop_in "Permalink")

在 GitLab 12.8 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/20956) .

`auto_stop_in`关键字用于指定环境的生命周期，当 GitLab 过期时，它将自动停止它们.

例如，

```
review_app:
  script: deploy-review-app
  environment:
    name: review/$CI_COMMIT_REF_NAME
    auto_stop_in: 1 day 
```

当执行`review_app`作业并创建评论应用程序时，环境的生命周期设置为`1 day` .

有关更多信息，请参见[环境自动停止文档.](../environments/index.html#environments-auto-stop)

#### `environment:kubernetes`[](#environmentkubernetes "Permalink")

在 GitLab 12.6 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/27630) .

`kubernetes`块用于将部署配置为与您的项目关联的[Kubernetes 集群](../../user/project/clusters/index.html) .

例如：

```
deploy:
  stage: deploy
  script: make deploy-app
  environment:
    name: production
    kubernetes:
      namespace: production 
```

这将使用`production` [Kubernetes 名称空间](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/)设置`deploy`作业以部署到`production`环境.

有关更多信息，请参阅[`kubernetes`可用设置](../environments/index.html#configuring-kubernetes-deployments) .

**注意：** [由 GitLab 管理的](../../user/project/clusters/index.html#gitlab-managed-clusters) Kubernetes 集群不支持 Kubernetes 配置. 要跟踪对 GitLab 管理的集群的支持进度，请参阅[相关问题](https://gitlab.com/gitlab-org/gitlab/-/issues/38054) .

#### Dynamic environments[](#dynamic-environments "Permalink")

版本历史

*   在 GitLab 8.12 和 GitLab Runner 1.6 中[引入](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/21971) .
*   `$CI_ENVIRONMENT_SLUG`是在 GitLab 8.15 中[引入的](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/22864) .
*   `name`和`url`参数可以使用任何已定义的 CI 变量，包括预定义的安全变量和`.gitlab-ci.yml` [`variables`](#variables) . 但是，您不能使用`script`下定义的变量.

例如：

```
deploy as review app:
  stage: deploy
  script: make deploy
  environment:
    name: review/$CI_COMMIT_REF_NAME
    url: https://$CI_ENVIRONMENT_SLUG.example.com/ 
```

`deploy as review app`作业将被标记为部署，以动态创建`review/$CI_COMMIT_REF_NAME`环境，其中`$CI_COMMIT_REF_NAME`是 Runner 设置的[环境变量](../variables/README.html) . `$CI_ENVIRONMENT_SLUG`变量基于环境名称，但适合包含在 URL 中. 在这种情况下，如果" `deploy as review app`作业在名为`pow`的分支中运行，则可以使用`https://review-pow.example.com/`类的 URL 访问此环境.

当然，这意味着托管应用程序的基础服务器已正确配置.

常见的用例是为分支创建动态环境并将其用作 Review Apps. 您可以在[https://gitlab.com/gitlab-examples/review-apps-nginx/上](https://gitlab.com/gitlab-examples/review-apps-nginx/)查看使用 Review Apps 的简单示例.

### `cache`[](#cache "Permalink")

版本历史

*   在 GitLab Runner v0.7.0 中引入.
*   `cache`可以全局设置，也可以按作业设置.
*   从 GitLab 9.0 起，默认情况下启用缓存并在管道和作业之间共享缓存.
*   从 GitLab 9.2 起，缓存将在[工件](#artifacts)之前恢复.

**了解更多信息：**阅读缓存工作原理，并在[缓存依赖文档中](../caching/index.html)找到一些好的做法.

`cache`用于指定应在作业之间缓存的文件和目录的列表. 您只能使用本地工作副本中的路径.

如果在作业范围之外定义了`cache` ，则意味着已全局设置`cache` ，并且所有作业都将使用该定义.

#### `cache:paths`[](#cachepaths "Permalink")

使用`paths`指令选择要缓存的文件或目录. 路径是相对于项目目录（ `$CI_PROJECT_DIR` ）的，不能直接链接到其外部. 可以使用遵循[通配符](https://en.wikipedia.org/wiki/Glob_(programming))模式的[通配符，](https://en.wikipedia.org/wiki/Glob_(programming))并且：

*   在[GitLab Runner 13.0](https://gitlab.com/gitlab-org/gitlab-runner/-/issues/2620)和更高版本中，请选择[`doublestar.Glob`](https://pkg.go.dev/github.com/bmatcuk/doublestar@v1.2.2?tab=doc#Match) .
*   在 GitLab Runner 12.10 及更早版本中， [`filepath.Match`](https://pkg.go.dev/path/filepath/#Match) .

将所有文件缓存在以`.apk`和`.config`文件结尾的`binaries`文件中：

```
rspec:
  script: test
  cache:
    paths:
      - binaries/*.apk
      - .config 
```

本地定义的缓存将覆盖全局定义的选项. 以下`rspec`作业将仅缓存`binaries/` ：

```
cache:
  paths:
    - my/files

rspec:
  script: test
  cache:
    key: rspec
    paths:
      - binaries/ 
```

请注意，由于缓存是在作业之间共享的，因此如果您为不同的作业使用不同的路径，则还应该设置不同的**cache：key，**否则缓存内容可能会被覆盖.

#### `cache:key`[](#cachekey "Permalink")

在 GitLab Runner v1.0.0 中引入.

由于缓存是在作业之间共享的，因此如果您为不同的作业使用不同的路径，则还应该设置不同的`cache:key`否则缓存内容可能会被覆盖.

`key`指令允许您定义作业之间的缓存相似性，从而允许为所有作业使用单个缓存，按作业缓存，按分支缓存或适合您工作流程的任何其他方式. 这样，您可以微调缓存，从而允许您在不同作业甚至不同分支之间缓存数据.

`cache:key`变量可以使用任何[预定义的变量](../variables/README.html) ，并且默认键（如果未设置）只是文字`default` ，这意味着从 GitLab 9.0 开始，默认情况下所有内容都在管道和作业之间共享.

**注意：** `cache:key`变量不能包含`/`字符或等效的 URI 编码的`/` ； 也禁止仅由点（ `.` ， `.` ）组成的值.

例如，要启用每分支缓存：

```
cache:
  key: "$CI_COMMIT_REF_SLUG"
  paths:
    - binaries/ 
```

如果使用**Windows Batch**运行 Shell 脚本，则需要将`$`替换`$` `%` ：

```
cache:
  key: "%CI_COMMIT_REF_SLUG%"
  paths:
    - binaries/ 
```

##### `cache:key:files`[](#cachekeyfiles "Permalink")

[介绍](https://gitlab.com/gitlab-org/gitlab/-/issues/18986)在 GitLab v12.5.

The `cache:key:files` keyword extends the `cache:key` functionality by making it easier to reuse some caches, and rebuild them less often, which will speed up subsequent pipeline runs.

当包含`cache:key:files` ，还必须列出将用于生成密钥的项目文件，最多两个文件. 缓存`key`将是根据更改给定文件的最新提交（最多两个，如果列出了两个文件）计算出的 SHA 校验和. 如果在任何提交中都没有更改文件，则后备密钥将为`default` .

```
cache:
  key:
    files:
      - Gemfile.lock
      - package.json
  paths:
    - vendor/ruby
    - node_modules 
```

在此示例中，我们将为 Ruby 和 Node.js 依赖关系创建一个缓存，该缓存与`Gemfile.lock`和`package.json`文件的当前版本相关`Gemfile.lock` . 只要这些文件之一发生更改，就会计算新的缓存键并创建新的缓存. 任何将来的作业都使用相同的`Gemfile.lock`和`package.json`和`cache:key:files`将使用新的缓存，而不是重建依赖关系.

##### `cache:key:prefix`[](#cachekeyprefix "Permalink")

[介绍](https://gitlab.com/gitlab-org/gitlab/-/issues/18986)在 GitLab v12.5.

`prefix`参数通过允许密钥由给定的`prefix`与为`cache:key:files`计算的 SHA 组合而成，从而为`key:files`添加了额外的功能. 例如，添加`test`的`prefix`将导致键看起来像： `test-feef9576d21ee9b6a32e30c5c79d0a0ceb68d1e5` . 如果在任何提交中都未更改两个文件，则将前缀添加到`default` ，因此示例中的键将为`test-default` .

像`cache:key`一样， `prefix`可以使用任何[预定义的变量](../variables/README.html) ，但是不允许以下操作：

*   `/`字符（或等效的 URI 编码的`/` ）
*   仅由组成的值`.` （或等效的 URI 编码的`.` ）

```
cache:
  key:
    files:
      - Gemfile.lock
    prefix: ${CI_JOB_NAME}
  paths:
    - vendor/ruby

rspec:
  script:
    - bundle exec rspec 
```

例如，添加`$CI_JOB_NAME` `prefix`将使密钥看起来像： `rspec-feef9576d21ee9b6a32e30c5c79d0a0ceb68d1e5` ，并且作业缓存在不同分支之间共享. 如果分支更改`Gemfile.lock` ，则该分支将为`cache:key:files`具有新的 SHA 校验和. 将生成一个新的缓存密钥，并为该密钥创建一个新的缓存. 如果未找到`Gemfile.lock` ，则将前缀添加到`default` ，因此示例中的键将为`rspec-default` .

#### `cache:untracked`[](#cacheuntracked "Permalink")

设置`untracked: true`以缓存 Git 存储库中所有未跟踪的文件：

```
rspec:
  script: test
  cache:
    untracked: true 
```

缓存所有 Git 未跟踪的文件和`binaries` ：

```
rspec:
  script: test
  cache:
    untracked: true
    paths:
      - binaries/ 
```

#### `cache:policy`[](#cachepolicy "Permalink")

在 GitLab 9.4 中引入.

缓存作业的默认行为是在执行开始时下载文件，然后在结束时重新上传文件. 这样可以将作业所做的任何更改保留下来，以备将来运行，这被称为" `pull-push`缓存策略.

如果您知道该作业不会更改缓存的文件，则可以通过设置`policy: pull`来跳过上载步骤`policy: pull`插入作业规范. 通常，这会在较早的阶段与普通的缓存作业结合在一起，以确保不时更新缓存：

```
stages:
  - setup
  - test

prepare:
  stage: setup
  cache:
    key: gems
    paths:
      - vendor/bundle
  script:
    - bundle install --deployment

rspec:
  stage: test
  cache:
    key: gems
    paths:
      - vendor/bundle
    policy: pull
  script:
    - bundle exec rspec ... 
```

这有助于加快作业执行速度并减少缓存服务器上的负载，尤其是当您有大量并行使用缓存的作业时.

此外，如果您有一项作业无条件地重新创建了高速缓存而不参考其先前的内容，则可以使用`policy: push`该作业以跳过下载步骤.

### `artifacts`[](#artifacts "Permalink")

版本历史

*   在非 Windows 平台的 GitLab Runner v0.7.0 中引入.
*   Windows 支持已在 GitLab Runner v.1.0.0 中添加.
*   从 GitLab 9.2 起，缓存将在工件之前恢复.
*   并非所有执行程序都[受支持](https://docs.gitlab.com/runner/executors/) .
*   默认情况下，仅为成功的作业收集作业工件.

`artifacts`用于指定在[成功，失败或始终成功](#artifactswhen)时应附加到作业的文件和目录的列表.

作业完成后，工件将被发送到 GitLab，并可在 GitLab UI 中下载.

[Read more about artifacts](../pipelines/job_artifacts.html).

#### `artifacts:paths`[](#artifactspaths "Permalink")

路径是相对于项目目录（ `$CI_PROJECT_DIR` ）的，不能直接链接到其外部. 可以使用遵循[通配符](https://en.wikipedia.org/wiki/Glob_(programming))模式和[`filepath.Match`](https://s0golang0org.icopy.site/pkg/path/filepath/)的[通配符](https://en.wikipedia.org/wiki/Glob_(programming)) .

要限制特定作业将从中获取工件的作业，请参阅[dependencies](#dependencies) .

发送所有`binaries`和`.config`文件：

```
artifacts:
  paths:
    - binaries/
    - .config 
```

要禁用工件传递，请使用空的[依赖项](#dependencies)定义作业：

```
job:
  stage: build
  script: make build
  dependencies: [] 
```

您可能只想为标记的发行版创建构件，以避免用临时构建构件填充构建服务器存储.

仅为标签创建工件（ `default-job`不会创建工件）：

```
default-job:
  script:
    - mvn test -U
  except:
    - tags

release-job:
  script:
    - mvn package -U
  artifacts:
    paths:
      - target/*.war
  only:
    - tags 
```

您也可以为目录使用通配符. 例如，如果要获取以`xyz`结尾的目录中的所有文件：

```
job:
  artifacts:
    paths:
      - path/*xyz/* 
```

#### `artifacts:exclude`[](#artifactsexclude "Permalink")

版本历史

*   在 GitLab 13.1 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/15122)
*   需要 GitLab Runner 13.1

`exclude`可以防止将文件添加到工件存档中.

类似于[`artifacts:paths`](#artifactspaths) ， `exclude`路径相对于项目目录. 可以使用遵循[通配符](https://en.wikipedia.org/wiki/Glob_(programming))模式和[`filepath.Match`](https://s0golang0org.icopy.site/pkg/path/filepath/)的[通配符](https://en.wikipedia.org/wiki/Glob_(programming)) .

例如，所有的文件存储在`binaries/` ，而不是`*.o`位于的子目录中的文件`binaries/` ：

```
artifacts:
  paths:
    - binaries/
  exclude:
    - binaries/**/*.o 
```

与[`artifacts:untracked`](#artifactsuntracked)匹配的文件也可以使用`artifacts:exclude` .

#### `artifacts:expose_as`[](#artifactsexpose_as "Permalink")

在 GitLab 12.5 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/15018) .

关键字`expose_as`可用于在[合并请求](../../user/project/merge_requests/index.html) UI 中公开[作业工件](../pipelines/job_artifacts.html) .

例如，要匹配单个文件：

```
test:
  script: [ "echo  'test'  >  file.txt" ]
  artifacts:
    expose_as: 'artifact  1'
    paths: ['file.txt'] 
```

使用此配置，GitLab 会将链接**工件 1**添加到指向`file1.txt`的相关合并请求中.

匹配整个目录的示例：

```
test:
  script: [ "mkdir  test  &&  echo  'test'  >  test/file.txt" ]
  artifacts:
    expose_as: 'artifact  1'
    paths: ['test/'] 
```

请注意以下几点：

*   使用变量定义`artifacts:paths`时，工件不会显示在合并请求 UI 中.
*   每个合并请求最多可以公开 10 个作业工件.
*   不支持 glob 模式.
*   如果指定了目录，那么如果目录中有多个文件，则该链接将指向作业[工件浏览器](../pipelines/job_artifacts.html#browsing-artifacts) .
*   对于带有`.html` ， `.htm` ， `.txt` ， `.json` ， `.xml`和`.log`扩展名的暴露的单个文件工件，如果[GitLab Pages](../../administration/pages/index.html)为：
    *   启用后，GitLab 将自动渲染工件.
    *   未启用，您将在工件浏览器中看到该文件.

#### `artifacts:name`[](#artifactsname "Permalink")

在 GitLab 8.6 和 GitLab Runner v1.1.0 中引入.

通过`name`指令，您可以定义所创建的工件存档的名称. 这样，您可以为每个档案使用一个唯一的名称，这在您要从 GitLab 下载档案时很有用. `artifacts:name`变量可以使用任何[预定义变量](../variables/README.html) . 默认名称是`artifacts` ，下载`artifacts`变为`artifacts.zip` .

**注意：**如果您的分支名称包含正斜杠（例如`feature/my-feature` ），建议使用`$CI_COMMIT_REF_SLUG`而不是`$CI_COMMIT_REF_NAME`来正确命名工件.

要使用当前作业的名称创建档案：

```
job:
  artifacts:
    name: "$CI_JOB_NAME"
    paths:
      - binaries/ 
```

要使用当前分支或标记的名称（仅包括二进制文件目录）创建档案，请执行以下操作：

```
job:
  artifacts:
    name: "$CI_COMMIT_REF_NAME"
    paths:
      - binaries/ 
```

要使用当前作业的名称和当前分支或标记（仅包括二进制文件目录）创建档案，请执行以下操作：

```
job:
  artifacts:
    name: "$CI_JOB_NAME-$CI_COMMIT_REF_NAME"
    paths:
      - binaries/ 
```

要创建一个具有当前[阶段](#stages)名称和分支名称的档案：

```
job:
  artifacts:
    name: "$CI_JOB_STAGE-$CI_COMMIT_REF_NAME"
    paths:
      - binaries/ 
```

* * *

如果使用**Windows Batch**运行 Shell 脚本，则需要将`$`替换`$` `%` ：

```
job:
  artifacts:
    name: "%CI_JOB_STAGE%-%CI_COMMIT_REF_NAME%"
    paths:
      - binaries/ 
```

如果使用**Windows PowerShell**运行 Shell 脚本，则需要将`$`替换`$` `$env:` ：：

```
job:
  artifacts:
    name: "$env:CI_JOB_STAGE-$env:CI_COMMIT_REF_NAME"
    paths:
      - binaries/ 
```

#### `artifacts:untracked`[](#artifactsuntracked "Permalink")

`artifacts:untracked`用于将所有 Git 未跟踪的文件添加为工件（以及`artifacts:paths`定义的`artifacts:paths` ）.

**Note:** `artifacts:untracked` ignores configuration in the repository’s `.gitignore` file.

发送所有未跟踪的 Git 文件：

```
artifacts:
  untracked: true 
```

发送所有 Git 未跟踪的文件和`binaries` ：

```
artifacts:
  untracked: true
  paths:
    - binaries/ 
```

发送所有未跟踪的文件，但[不包括](#artifactsexclude) `*.txt` ：

```
artifacts:
  untracked: true
  exclude:
    - *.txt 
```

#### `artifacts:when`[](#artifactswhen "Permalink")

在 GitLab 8.9 和 GitLab Runner v1.3.0 中引入.

`artifacts:when`用于在作业失败时或尽管失败而上传工件.

可以设置为以下值之一的`artifacts:when` ：

1.  `on_success`仅在作业成功时才上传工件. 这是默认值.
2.  `on_failure`仅在作业失败时上载工件.
3.  `always` -上载工件，无论作业状态如何.

要仅在作业失败时上传工件：

```
job:
  artifacts:
    when: on_failure 
```

#### `artifacts:expire_in`[](#artifactsexpire_in "Permalink")

在 GitLab 8.9 和 GitLab Runner v1.3.0 中引入.

`expire_in` allows you to specify how long artifacts should live before they expire and are therefore deleted, counting from the time they are uploaded and stored on GitLab. If the expiry time is not defined, it defaults to the [instance wide setting](../../user/admin_area/settings/continuous_integration.html#default-artifacts-expiration-core-only) (30 days by default).

您可以使用作业页面上的" **保留"**按钮来覆盖过期并永久保留工件.

过期后，默认情况下每小时（通过 cron 作业）删除工件，并且不再可用.

The value of `expire_in` is an elapsed time in seconds, unless a unit is provided. Examples of valid values:

*   `42`
*   `3 mins 4 sec`
*   `2 hrs 20 min`
*   `2h20min`
*   `6 mos 1 day`
*   `47 yrs 6 mos and 4d`
*   `3 weeks and 2 days`

要在上传后 1 周内使工件过期：

```
job:
  artifacts:
    expire_in: 1 week 
```

**注意：**对于在[GitLab 13.1](https://gitlab.com/gitlab-org/gitlab/-/issues/16267)和更高版本中创建的工件，无论有效时间如何，始终会保留引用的最新工件.

#### `artifacts:reports`[](#artifactsreports "Permalink")

[`artifacts:reports`关键字](../pipelines/job_artifacts.html#artifactsreports)用于从作业中收集测试报告，代码质量报告和安全性报告. 它还在 GitLab 的 UI 中显示这些报告（合并请求，管道视图和安全性仪表板）.

这些是可用的报告类型：

| Parameter | Description |
| --- | --- |
| [`artifacts:reports:junit`](../pipelines/job_artifacts.html#artifactsreportsjunit) | `junit`报告收集 JUnit XML 文件. |
| [`artifacts:reports:dotenv`](../pipelines/job_artifacts.html#artifactsreportsdotenv) | `dotenv`报告收集一组环境变量. |
| [`artifacts:reports:cobertura`](../pipelines/job_artifacts.html#artifactsreportscobertura) | `cobertura`报告收集 Co​​bertura coverage XML 文件. |
| [`artifacts:reports:terraform`](../pipelines/job_artifacts.html#artifactsreportsterraform) | `terraform`报告收集 Terraform `tfplan.json`文件. |
| [`artifacts:reports:codequality`](../pipelines/job_artifacts.html#artifactsreportscodequality-starter) | `codequality`报告收集 Co​​deQuality 问题. |
| [`artifacts:reports:sast`](../pipelines/job_artifacts.html#artifactsreportssast-ultimate) | `sast`报告收集"静态应用程序安全性测试"漏洞. |
| [`artifacts:reports:dependency_scanning`](../pipelines/job_artifacts.html#artifactsreportsdependency_scanning-ultimate) | `dependency_scanning`报告收集"依赖关系扫描"漏洞. |
| [`artifacts:reports:container_scanning`](../pipelines/job_artifacts.html#artifactsreportscontainer_scanning-ultimate) | `container_scanning`报告收集容器扫描漏洞. |
| [`artifacts:reports:dast`](../pipelines/job_artifacts.html#artifactsreportsdast-ultimate) | `dast`报告收集动态应用程序安全测试漏洞. |
| [`artifacts:reports:license_management`](../pipelines/job_artifacts.html#artifactsreportslicense_management-ultimate) | `license_management`报告收集许可证（ *已从 GitLab 13.0 中删除* ）. |
| [`artifacts:reports:license_scanning`](../pipelines/job_artifacts.html#artifactsreportslicense_scanning-ultimate) | `license_scanning`报告收集许可证. |
| [`artifacts:reports:performance`](../pipelines/job_artifacts.html#artifactsreportsperformance-premium) | `performance`报告收集绩效指标. |
| [`artifacts:reports:metrics`](../pipelines/job_artifacts.html#artifactsreportsmetrics-premium) | `metrics`报告收集指标. |

#### `dependencies`[](#dependencies "Permalink")

在 GitLab 8.6 和 GitLab Runner v1.1.1 中引入.

默认情况下，所有先前[阶段的](#stages)所有[`artifacts`](#artifacts)都被传递，但是您可以使用`dependencies`参数来定义要从中获取工件的有限的作业列表（或没有作业）.

要使用此功能，请在作业的上下文中定义`dependencies` ，并传递所有以前的工件应从中下载工件的列表. 您只能从当前阶段之前执行的阶段定义作业. 如果您从当前阶段或下一个阶段定义作业，将显示错误. 定义一个空数组将跳过下载该作业的任何工件. 在使用`dependencies` ，不会考虑先前作业的状态，因此，如果它失败或它是未运行的手动作业，则不会发生错误.

在以下示例中，我们使用工件定义了两个作业`build:osx`和`build:linux` . 当执行`test:osx` ，将在`build:osx`上下文中下载并提取来自`build:osx`的工件. `test:linux`和`build:linux`工件也发生了同样的情况.

由于[阶段](#stages)优先，作业`deploy`将下载所有先前作业的工件：

```
build:osx:
  stage: build
  script: make build:osx
  artifacts:
    paths:
      - binaries/

build:linux:
  stage: build
  script: make build:linux
  artifacts:
    paths:
      - binaries/

test:osx:
  stage: test
  script: make test:osx
  dependencies:
    - build:osx

test:linux:
  stage: test
  script: make test:linux
  dependencies:
    - build:linux

deploy:
  stage: deploy
  script: make deploy 
```

##### When a dependent job will fail[](#when-a-dependent-job-will-fail "Permalink")

在 GitLab 10.3 中引入.

如果设置为依赖项的作业的工件已[过期](#artifactsexpire_in)或已[擦除](../pipelines/job_artifacts.html#erasing-artifacts) ，则依赖项作业将失败.

**注意：**您可以要求管理员[翻转此开关](../../administration/job_artifacts.html#validation-for-dependencies)并恢复原来的行为.

### `coverage`[](#coverage "Permalink")

在 GitLab 8.17 中[引入](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/20428) .

`coverage`允许您配置如何从作业输出中提取代码 coverage.

正则表达式是此处期望的唯一有效值. 因此，必须使用周围的`/` ，以便一致且显式表示正则表达式字符串. 如果要按字面意义匹配特殊字符，则必须转义它们.

一个简单的例子：

```
job1:
  script: rspec
  coverage: '/Code  coverage:  \d+\.\d+/' 
```

### `retry`[](#retry "Permalink")

版本历史

*   在 GitLab 9.5 中[引入](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/3442) .
*   [行为](https://gitlab.com/gitlab-org/gitlab-runner/-/issues/3515)在 GitLab 11.5 中进行了[扩展](https://gitlab.com/gitlab-org/gitlab-runner/-/issues/3515) ，以控制重试哪些失败.

`retry`允许您配置在失败的情况下重试作业的次数.

当作业失败并配置了`retry` ，它将再次处理，直到`retry`关键字指定的时间.

如果`retry`设置为 2，并且作业在第二次运行中成功（第一次重试），则不会再次重试. `retry`值必须是一个正整数，等于或大于 0，但小于或等于 2（最多两次重试，总共运行 3 次）.

在所有失败情况下重试的简单示例：

```
test:
  script: rspec
  retry: 2 
```

默认情况下，将在所有失败情况下重试作业. 为了更好地控制重`retry`哪些失败，重`retry`可以是具有以下键的哈希值：

*   `max` ：最大重试次数.
*   `when` ：失败案例重试.

要最多仅重试运行程序系统故障两次：

```
test:
  script: rspec
  retry:
    max: 2
    when: runner_system_failure 
```

如果有其他故障，而不是运行器系统故障，则不会重试该作业.

重试对多个故障的情况下， `when`也可以是故障的数组：

```
test:
  script: rspec
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure 
```

`when`可能值为：

*   `always` ：发生任何故障时重试（默认）.
*   `unknown_failure` ：当失败原因未知时重试.
*   `script_failure` ：脚本失败时重试.
*   `api_failure` ：API 失败重试.
*   `stuck_or_timeout_failure` ：作业卡住或超时时重试.
*   `runner_system_failure` ：如果运行系统发生故障（例如，作业设置失败），请重试.
*   `missing_dependency_failure` ：如果缺少依赖项，请重试.
*   `runner_unsupported` ：如果跑步者不受支持，请重试.
*   `stale_schedule` ：如果无法执行延迟的作业，请重试.
*   `job_execution_timeout` ：如果脚本超出了为作业设置的最大执行时间，则重试.
*   `archived_failure` ：如果作业已存档且无法运行，请重试.
*   `unmet_prerequisites` ：如果作业未能完成先决条件任务，请重试.
*   `scheduler_failure` ：如果调度程序未能将作业分配给运行`scheduler_failure`重试.
*   `data_integrity_failure` ：如果检测到结构完整性问题，请重试.

您可以使用变量指定[作业执行某些阶段的重试次数](#job-stages-attempts) .

### `timeout`[](#timeout "Permalink")

在 GitLab 12.3 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/14887) .

`timeout`允许您为特定作业配置超时. 例如：

```
build:
  script: build.sh
  timeout: 3 hours 30 minutes

test:
  script: rspec
  timeout: 3h 30m 
```

作业级超时可以超过[项目级超时，](../pipelines/settings.html#timeout)但不能超过 Runner 特定的超时.

### `parallel`[](#parallel "Permalink")

在 GitLab 11.5 中[引入](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/21480) .

`parallel`允许您配置要并行运行的作业实例数. 此值必须大于或等于两（2）并且小于或等于 50.

这将创建 N 个并行运行的同一作业实例. 它们从`job_name 1/N`到`job_name N/N`依次命名.

对于每个作业， `CI_NODE_INDEX`设置`CI_NODE_INDEX`和`CI_NODE_TOTAL` [环境变量](../variables/README.html#predefined-environment-variables) .

标记要并行运行的作业需要将`parallel`添加到配置文件中. 例如：

```
test:
  script: rspec
  parallel: 5 
```

**提示：**跨并行作业并行测试套件. 不同的语言具有不同的工具来促进这一点.

一个使用[信号量测试助推器](https://github.com/renderedtext/test-boosters)和 RSpec 来运行一些 Ruby 测试的简单示例：

```
# Gemfile
source 'https://rubygems.org'

gem 'rspec'
gem 'semaphore_test_boosters' 
```

```
test:
  parallel: 3
  script:
    - bundle
    - bundle exec rspec_booster --job $CI_NODE_INDEX/$CI_NODE_TOTAL 
```

**警告：**请注意 semaphore_test_boosters 向作者报告使用情况统计信息.

然后，您可以导航到新管道构建的" **作业"**选项卡，并查看 RSpec 作业分为三个单独的作业.

### `trigger`[](#trigger "Permalink")

版本历史

*   在[GitLab Premium](https://about.gitlab.com/pricing/) 11.8 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/8997) .
*   在 12.8 中[移至](https://gitlab.com/gitlab-org/gitlab/-/issues/199224) GitLab Core.

`trigger`允许您定义下游管道触发器. 当 GitLab 从`trigger`定义创建的作业启动时，将创建一个下游管道.

此关键字允许创建两种不同类型的下游管道：

*   [Multi-project pipelines](../multi_project_pipelines.html#creating-multi-project-pipelines-from-gitlab-ciyml)
*   [Child pipelines](../parent_child_pipelines.html)

**注意：**将`trigger`与`when:manual`一起使用会导致错误`jobs:#{job-name} when should be on_success, on_failure or always` ，因为`when:manual`阻止使用触发器.

#### Simple `trigger` syntax for multi-project pipelines[](#simple-trigger-syntax-for-multi-project-pipelines "Permalink")

配置下游触发器的最简单方法是使用带有指向下游项目的完整路径的`trigger`关键字：

```
rspec:
  stage: test
  script: bundle exec rspec

staging:
  stage: deploy
  trigger: my/deployment 
```

#### Complex `trigger` syntax for multi-project pipelines[](#complex-trigger-syntax-for-multi-project-pipelines "Permalink")

可以配置分支名称，GitLab 将使用该分支名称来创建下游管道：

```
rspec:
  stage: test
  script: bundle exec rspec

staging:
  stage: deploy
  trigger:
    project: my/deployment
    branch: stable 
```

可以从触发的管道中镜像状态：

```
trigger_job:
  trigger:
    project: my/project
    strategy: depend 
```

可以从上游管道镜像状态：

```
upstream_bridge:
  stage: test
  needs:
    pipeline: other/project 
```

#### `trigger` syntax for child pipeline[](#trigger-syntax-for-child-pipeline "Permalink")

在 GitLab 12.7 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/16094) .

要创建[子管道](../parent_child_pipelines.html) ，请指定包含子管道的 CI 配置的 YAML 文件的路径：

```
trigger_job:
  trigger:
    include: path/to/child-pipeline.yml 
```

类似于[多项目管道](../multi_project_pipelines.html#mirroring-status-from-triggered-pipeline) ，可以从触发的管道中镜像状态：

```
trigger_job:
  trigger:
    include:
      - local: path/to/child-pipeline.yml
    strategy: depend 
```

##### Trigger child pipeline with generated configuration file[](#trigger-child-pipeline-with-generated-configuration-file "Permalink")

在 GitLab 12.9 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/35632) .

您还可以从[动态生成的配置文件](../parent_child_pipelines.html#dynamic-child-pipelines)触发子管道：

```
generate-config:
  stage: build
  script: generate-ci-config > generated-config.yml
  artifacts:
    paths:
      - generated-config.yml

child-pipeline:
  stage: test
  trigger:
    include:
      - artifact: generated-config.yml
        job: generate-config 
```

从工件中提取了`generated-config.yml` ，并用作触发子管道的配置.

#### Linking pipelines with `trigger:strategy`[](#linking-pipelines-with-triggerstrategy "Permalink")

默认情况下，一旦创建下游管道， `trigger`作业就会以`success`状态完成.

要强制`trigger`作业等待下游（多项目或子项目）管道完成，请使用`strategy: depend` . 这将使触发作业以"运行"状态等待，直到触发的管道完成. 此时， `trigger`作业将完成并显示与下游作业相同的状态.

```
trigger_job:
  trigger:
    include: path/to/child-pipeline.yml
    strategy: depend 
```

这可以使您的管道执行保持线性. 在上面的示例中，后续阶段的作业将在启动之前等待触发的管道成功完成，但代价是并行化程度降低.

#### Trigger a pipeline by API call[](#trigger-a-pipeline-by-api-call "Permalink")

当使用触发器令牌创建管道时，触发器可以用于通过 API 调用强制重建特定的分支，标记或提交.

不要与[`trigger`](#trigger)参数混淆.

[Read more in the triggers documentation.](../triggers/README.html)

### `interruptible`[](#interruptible "Permalink")

在 GitLab 12.3 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/32022) .

`interruptible`可用于指示如果作业因新的管道运行而变得多余，则应取消该作业. 默认为`false` . 仅当启用了[自动取消冗余管道功能](../pipelines/settings.html#auto-cancel-pending-pipelines)时，才使用此值.

启用后，在以下情况下，将取消同一分支上的管道：

*   它通过新的管道运行而变得多余.
*   将所有作业都设置为可中断，或者尚未开始任何不间断的作业.

待处理的作业始终被视为可中断的.

**Tip:** Set jobs as interruptible that can be safely canceled once started (for instance, a build job).

这是一个简单的示例：

```
stages:
  - stage1
  - stage2
  - stage3

step-1:
  stage: stage1
  script:
    - echo "Can be canceled."
  interruptible: true

step-2:
  stage: stage2
  script:
    - echo "Can not be canceled."

step-3:
  stage: stage3
  script:
    - echo "Because step-2 can not be canceled, this step will never be canceled, even though set as interruptible."
  interruptible: true 
```

在上面的示例中，新的管道运行将导致现有的正在运行的管道为：

*   如果仅`step-1`正在运行或挂起，则取消.
*   一旦`step-2`开始运行，则不会取消.

**注意：**一旦运行了不间断的作业，无论最终作业的状态如何，管道将永远不会被取消.

### `resource_group`[](#resource_group "Permalink")

在 GitLab 12.7 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/15536) .

有时在环境中同时运行多个作业或管道可能会导致在部署过程中出错.

为了避免这些错误，可以使用`resource_group`属性来确保 Runner 不会同时运行某些作业.

当在`.gitlab-ci.yml`为作业定义了`resource_group`键时，作业执行在同一项目的不同管道之间是互斥的. 如果属于同一资源组的多个作业同时进入队列，则 Runner 将仅选择一个作业，其他作业将等待，直到`resource_group`空闲为止.

这是一个简单的示例：

```
deploy-to-production:
  script: deploy
  resource_group: production 
```

在这种情况下，如果`deploy-to-production`作业在管道运行，并且新的`deploy-to-production`中不同的管道创建工作，它不会运行，直到当前运行的/未决`deploy-to-production`工作完成. 结果，您可以确保并发部署永远不会在生产环境中发生.

每个环境可以定义多个`resource_group` . 一个很好的用例是在部署到物理设备时. 您可能具有多个物理设备，并且每个物理设备都可以部署到其中，但是在任何给定时间，每个设备只能有一个部署.

**注：**此键只能包含字母，数字， `-` `_` ， `/` ， `$` ， `{` ， `}` ， `.` 和空格. 它不能以`/`开头或结尾.

有关更多信息，请参见[部署安全](../environments/deployment_safety.html) .

### `release`[](#release "Permalink")

在 GitLab 13.2 中[引入](https://gitlab.com/gitlab-org/gitlab/merge_requests/19298) .

`release`表示作业创建一个[Release](../../user/project/releases/index.html) ，并且可以选择包含 Release 资产的 URL.

支持以下方法：

*   [`tag_name`](#releasetag_name)
*   [`name`](#releasename) (optional)
*   [`description`](#releasedescription) (optional)
*   [`ref`](#releaseref) (optional)
*   [`milestones`](#releasemilestones) (optional)
*   [`released_at`](#releasereleased_at) (optional)

仅当作业处理没有错误时才创建发布. 如果 Rails API 在发布创建期间返回错误，则`release`作业将失败.

#### `release-cli` Docker image[](#release-cli-docker-image "Permalink")

必须使用以下指令指定用于`release-cli`的 Docker 映像：

```
image: registry.gitlab.com/gitlab-org/release-cli:latest 
```

#### Script[](#script-1 "Permalink")

所有作业至少需要一个`script`标签. `:release`作业可以使用`:script`标记的输出，但是如果没有必要，则可以使用占位符脚本，例如：

```
script:
  - echo 'release job' 
```

在即将发布的 GitLab 版本中存在删除此要求的[问题](https://gitlab.com/gitlab-org/gitlab/-/issues/223856) .

管道可以具有多个`release`作业，例如：

```
ios-release:
  script:
    - echo 'iOS release job'
  release:
     tag_name: v1.0.0-ios
     description: 'iOS  release  v1.0.0'

android-release:
  script:
    - echo 'Android release job'
  release:
     tag_name: v1.0.0-android
     description: 'Android  release  v1.0.0' 
```

#### `release:tag_name`[](#releasetag_name "Permalink")

必须指定`tag_name` . 它可以引用现有的 Git 标记，也可以由用户指定.

当存储库中不存在指定的标签时，将从管道的关联 SHA 创建一个新标签.

例如，从 Git 标签创建 Release 时：

```
job:
  release:
    tag_name: $CI_COMMIT_TAG
    description: changelog.txt 
```

也可以创建任何唯一标签， `only: tags`在这种情况下`only: tags`不是必需的. 语义版本控制示例：

```
job:
  release:
    tag_name: ${MAJOR}_${MINOR}_${REVISION}
    description: changelog.txt 
```

*   仅当作业的主脚本成功时才创建发布.
*   如果版本已经存在，则不会更新，并且带有`release`关键字的作业将失败.
*   `release`部分在`script`标记之后和`after_script`之前`after_script` .

#### `release:name`[](#releasename "Permalink")

发布名称. 如果省略，则使用`release: tag_name`的值填充`release: tag_name` .

#### `release:description`[](#releasedescription "Permalink")

指定发布的详细描述.

#### `release:ref`[](#releaseref "Permalink")

如果`release: tag_name`尚不存在，则从`ref`创建版本. `ref`可以是提交 SHA，其他标记名称或分支名称.

#### `release:milestones`[](#releasemilestones "Permalink")

与发行版关联的每个里程碑的标题.

#### `release:released_at`[](#releasereleased_at "Permalink")

发布准备就绪的日期和时间. 如果未定义，则默认为当前日期和时间. 预期为 ISO 8601 格式（2019-03-15T08：00：00Z）.

#### Complete example for `release`[](#complete-example-for-release "Permalink")

结合上面给出的`release`示例，将产生以下代码段. 有两种选择，具体取决于生成标记的方式. 这些选项不能一起使用，因此请选择以下一种：

*   要在按下 Git 标签或在 UI 中通过添加**存储库>标签**来添加 Git 标签时创建发行版：

    ```
    release_job:
      stage: release
      image: registry.gitlab.com/gitlab-org/release-cli:latest
      rules:
        - if: $CI_COMMIT_TAG                  # Run this job when a tag is created manually
      script:
        - echo 'running release_job'
      release:
         name: 'Release  $CI_COMMIT_TAG'
         description: 'Created  using  the  release-cli  $EXTRA_DESCRIPTION' # $EXTRA_DESCRIPTION must be defined
         tag_name: '$CI_COMMIT_TAG'                                      # elsewhere in the pipeline.
         ref: '$CI_COMMIT_TAG'
         milestones:
           - 'm1'
           - 'm2'
           - 'm3'
         released_at: '2020-07-15T08:00:00Z'  # Optional, will auto generate if not defined,
                                              # or can use a variable. 
    ```

*   要使用更改定义的新 Git 标签，将更改推送到默认分支时自动创建发行版：

    ```
    release_job:
      stage: release
      image: registry.gitlab.com/gitlab-org/release-cli:latest
      rules:
        - if: $CI_COMMIT_TAG
          when: never                                 # Do not run this job when a tag is created manually
        - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH # Run this job when the default branch changes
      script:
        - echo 'running release_job'
      release:
         name: 'Release  $CI_COMMIT_SHA'
         description: 'Created  using  the  release-cli  $EXTRA_DESCRIPTION' # $EXTRA_DESCRIPTION and the tag_name
         tag_name: 'v${MAJOR}.${MINOR}.${REVISION}'                      # variables must be defined elsewhere
         ref: '$CI_COMMIT_SHA'                                           # in the pipeline.
         milestones:
           - 'm1'
           - 'm2'
           - 'm3'
         released_at: '2020-07-15T08:00:00Z'          # Optional, will auto generate if not defined,
                                                      # or can use a variable. 
    ```

#### `releaser-cli` command line[](#releaser-cli-command-line "Permalink")

`:release`节点下的条目被转换为`bash`命令行，并发送到包含[release-cli](https://gitlab.com/gitlab-org/release-cli)的 Docker 容器. 您也可以直接从`script`条目调用`release-cli` .

上面描述的 YAML 将被翻译成如下的 CLI 命令：

```
release-cli create --name "Release $CI_COMMIT_SHA" --description "Created using the release-cli $EXTRA_DESCRIPTION" --tag-name "v${MAJOR}.${MINOR}.${REVISION}" --ref "$CI_COMMIT_SHA" --released-at "2020-07-15T08:00:00Z" --milestone "m1" --milestone "m2" --milestone "m3" 
```

### `pages`[](#pages "Permalink")

`pages`是一项特殊的工作，用于将静态内容上传到 GitLab，可用于为您的网站提供服务. 它具有特殊的语法，因此必须满足以下两个要求：

*   任何静态内容都必须放在`public/`目录下.
*   必须定义带有`public/`目录路径的`artifacts` .

下面的示例只是将所有文件从项目的根目录移到`public/`目录. `.public`解决方法是，因此`cp`也不会在无限循环中将`public/`复制到自身：

```
pages:
  stage: deploy
  script:
    - mkdir .public
    - cp -r * .public
    - mv .public public
  artifacts:
    paths:
      - public
  only:
    - master 
```

阅读有关[GitLab Pages 用户文档的](../../user/project/pages/index.html)更多[信息](../../user/project/pages/index.html) .

## `variables`[](#variables "Permalink")

在 GitLab Runner v0.5.0 中引入.

**注意：**对于变量的名称和值，整数（以及字符串）都是合法的. 浮动广告不合法，不能使用.

GitLab CI / CD 允许您在`.gitlab-ci.yml`中定义变量，然后在作业环境中传递这些变量. 它们可以全局设置，也可以按工作设置. 在作业级别上使用`variables`关键字时，它将覆盖全局 YAML 变量和相同名称的预定义变量.

它们存储在 Git 存储库中，用于存储非敏感项目配置，例如：

```
variables:
  DATABASE_URL: "postgres://postgres@postgres/my_database" 
```

这些变量以后可以在所有执行的命令和脚本中使用. YAML 定义的变量也设置为所有创建的服务容器，从而允许对其进行微调.

除了用户定义的变量外，还有[由 Runner 本身设置的](../variables/README.html#predefined-environment-variables)变量. 一个示例是`CI_COMMIT_REF_NAME` ，它具有为其构建项目的分支或标记名称的值. 除了可以在`.gitlab-ci.yml`设置的变量`.gitlab-ci.yml` ，还有可以在 GitLab 的 UI 中设置的所谓[变量](../variables/README.html#gitlab-cicd-environment-variables) .

提供了[用于变量的 YAML 锚](#yaml-anchors-for-variables) .

了解有关[变量及其优先级的](../variables/README.html)更多信息.

### Git strategy[](#git-strategy "Permalink")

版本历史

*   在 GitLab 8.9 中作为实验功能引入.
*   `GIT_STRATEGY=none`要求 GitLab Runner `GIT_STRATEGY=none` +.

**注意：**在将来的版本中可能会更改或完全删除.

您可以在[`variables`](#variables)部分中全局或按作业设置用于获取最新应用程序代码的`GIT_STRATEGY` . 如果未指定，将使用项目设置中的默认设置.

有三个可能的值： `clone` ， `fetch`和`none` .

`clone`是最慢的选择. 它为每个作业从头克隆存储库，以确保本地工作副本始终是原始的.

```
variables:
  GIT_STRATEGY: clone 
```

`fetch`速度更快，因为它可以重新使用本地工作副本（如果不存在则回退到`clone` ）. `git clean`用于撤消上一个作业所做的任何更改，而`git fetch`用于检索自上一个作业运行以来进行的提交.

```
variables:
  GIT_STRATEGY: fetch 
```

`none`再使用本地工作副本，但是会跳过所有 Git 操作（包括 GitLab Runner 的预克隆脚本（如果存在））. 对于仅在工件上运行的作业（例如`deploy` ），它最有用. Git 存储库数据可能存在，但是肯定会过时，因此您应该仅依靠从缓存或工件导入本地工作副本的文件.

```
variables:
  GIT_STRATEGY: none 
```

**注意：** `GIT_STRATEGY`器不支持[GIT_STRATEGY](https://docs.gitlab.com/runner/executors/kubernetes.html) ，但将来可能会支持. 有关更新，请参阅[带有 Kubernetes 执行器功能建议](https://gitlab.com/gitlab-org/gitlab-runner/-/issues/3847)的[支持 Git 策略](https://gitlab.com/gitlab-org/gitlab-runner/-/issues/3847) .

### Git submodule strategy[](#git-submodule-strategy "Permalink")

> 需要 GitLab Runner v1.10 +.

`GIT_SUBMODULE_STRATEGY`变量用于控制在构建之前获取代码时是否包含/如何包含 Git 子模块. 您可以在[`variables`](#variables)部分中全局或按作业设置它们.

共有三个可能的值： `none` ， `normal`和`recursive` ：

*   `none`表示在获取项目代码时将不包含子模块. 这是默认设置，与 v1.10 之前的行为匹配.

*   `normal`意味着仅包括顶级子模块. 等效于：

    ```
    git submodule sync git submodule update --init 
    ```

*   `recursive`意味着将包括所有子模块（包括子模块的子模块）. 此功能需要 Git v1.8.1 及更高版本. 当将 GitLab Runner 与不基于 Docker 的执行器一起使用时，请确保 Git 版本符合该要求. 等效于：

    ```
    git submodule sync --recursive
    git submodule update --init --recursive 
    ```

请注意，为使此功能正常工作，必须使用以下任一方式（在`.gitmodules` ）配置子模块：

*   可公开访问的存储库的 HTTP（S）URL，或者
*   到同一 GitLab 服务器上另一个存储库的相对路径. 请参阅[Git 子模块](../git_submodules.html)文档.

### Git checkout[](#git-checkout "Permalink")

在 GitLab Runner 9.3 中引入.

当`GIT_STRATEGY`设置为`clone`或`fetch`以指定是否应运行`git checkout`时，可以使用`GIT_CHECKOUT`变量. 如果未指定，则默认为 true. 您可以在[`variables`](#variables)部分中全局或按作业设置它们.

如果设置为`false` ，则跑步者将：

*   进行`fetch` -更新存​​储库，并将工作副本保留在当前版本中，
*   执行`clone` -克隆存储库，并将工作副本保留在默认分支上.

将此设置设置为`true`意味着对于`clone`和`fetch`策略，Runner 将签出工作副本到与 CI 管道相关的修订版本：

```
variables:
  GIT_STRATEGY: clone
  GIT_CHECKOUT: "false"
script:
  - git checkout -B master origin/master
  - git merge $CI_COMMIT_SHA 
```

### Git clean flags[](#git-clean-flags "Permalink")

在 GitLab Runner 11.10 中引入

`GIT_CLEAN_FLAGS`变量用于在签出源代码后控制`git clean`的默认行为. 您可以在[`variables`](#variables)部分中全局设置或按作业设置.

`GIT_CLEAN_FLAGS`接受[`git clean`](https://git-scm.com/docs/git-clean)命令的所有可能选项.

如果指定了`GIT_CHECKOUT: "false"`则禁用`git clean` .

If `GIT_CLEAN_FLAGS` is:

*   未指定， `git clean`标志默认为`-ffdx` .
*   给定值`none` ，将不执行`git clean` .

例如：

```
variables:
  GIT_CLEAN_FLAGS: -ffdx -e cache/
script:
  - ls -al cache/ 
```

### Git fetch extra flags[](#git-fetch-extra-flags "Permalink")

在 GitLab Runner 13.1 中[引入](https://gitlab.com/gitlab-org/gitlab-runner/-/issues/4142) .

`GIT_FETCH_EXTRA_FLAGS`变量用于控制`git fetch`的行为. 您可以在[`variables`](#variables)部分中全局设置或按作业设置.

`GIT_FETCH_EXTRA_FLAGS`接受[`git fetch`](https://git-scm.com/docs/git-fetch)命令的所有可能选项，但请注意， `GIT_FETCH_EXTRA_FLAGS`标志将附加在无法修改的默认标志之后.

默认标志是：

*   [GIT_DEPTH](#shallow-cloning).
*   [refspec](https://git-scm.com/book/en/v2/Git-Internals-The-Refspec)列表.
*   遥远的`origin` .

If `GIT_FETCH_EXTRA_FLAGS` is:

*   未指定， `git fetch`标志与默认标志一起默认为`--prune --quiet` .
*   给定值`none` ，仅使用默认标志执行`git fetch` .

例如，默认标志是`--prune --quiet` ，因此您可以通过仅用`--prune`覆盖它来使`git fetch`更加详细：

```
variables:
  GIT_FETCH_EXTRA_FLAGS: --prune
script:
  - ls -al cache/ 
```

上面的配置将导致以这种方式调用`git fetch` ：

```
git fetch origin $REFSPECS --depth 50  --prune 
```

其中`$REFSPECS`是 GitLab 内部提供给 Runner 的值.

### Job stages attempts[](#job-stages-attempts "Permalink")

在 GitLab 中引入，它需要 GitLab Runner v1.9 +.

您可以设置正在运行的作业尝试执行以下每个阶段的尝试次数：

| Variable | Description |
| --- | --- |
| **GET_SOURCES_ATTEMPTS** | 尝试获取运行作业的源的次数 |
| **ARTIFACT_DOWNLOAD_ATTEMPTS** | 尝试下载运行作业的工件的次数 |
| **RESTORE_CACHE_ATTEMPTS** | 还原运行作业的缓存的尝试次数 |
| **EXECUTOR_JOB_SECTION_ATTEMPTS** | [从 GitLab 12.10 开始](https://gitlab.com/gitlab-org/gitlab-runner/-/issues/4450) ，出现[`No Such Container`](https://gitlab.com/gitlab-org/gitlab-runner/-/issues/4450)错误（仅限[Docker 执行器](https://docs.gitlab.com/runner/executors/docker.html) ）后，尝试在作业中运行部分的次数. |

默认为一次尝试.

Example:

```
variables:
  GET_SOURCES_ATTEMPTS: 3 
```

您可以在[`variables`](#variables)部分中全局或按作业设置它们.

### Shallow cloning[](#shallow-cloning "Permalink")

在 GitLab 8.9 中作为实验功能引入.

**注意** ：从 GitLab 12.0 开始，新创建的项目将自动具有[默认的`git depth`值`50`](../pipelines/settings.html#git-shallow-clone) .

您可以使用`GIT_DEPTH`指定获取和克隆的深度. 这允许对存储库进行浅层克隆，从而可以显着加快克隆具有大量提交或旧的大型二进制文件的存储库. 该值传递给`git fetch`和`git clone` .

**注意：**如果使用 1 的深度，并且有作业队列或重试作业，则作业可能会失败.

由于 Git 的获取和克隆基于引用（例如分支名称），因此 Runners 无法克隆特定的提交 SHA. 如果队列中有多个作业，或者您要重试旧的作业，则要测试的提交必须在克隆的 Git 历史记录内. 如果为`GIT_DEPTH`设置的值`GIT_DEPTH`则无法运行这些旧的提交. 您将在作业日志中看到`unresolved reference` . 然后，您应该重新考虑将`GIT_DEPTH`更改为更高的值.

设置`GIT_DEPTH`时，依赖`git describe`作业可能无法正常工作，因为仅存在一部分 Git 历史记录.

要仅获取或克隆最后 3 个提交，请执行以下操作：

```
variables:
  GIT_DEPTH: "3" 
```

您可以在[`variables`](#variables)部分中全局设置或按作业设置.

### Custom build directories[](#custom-build-directories "Permalink")

在 GitLab Runner 11.10 中[引入](https://gitlab.com/gitlab-org/gitlab-runner/-/issues/2211)

**注意：**仅当在[Runner 的配置中](https://docs.gitlab.com/runner/configuration/advanced-configuration.html)启用`custom_build_dir`时，才可以使用此`custom_build_dir` . 这是默认配置`docker`和`kubernetes`执行.

默认情况下，GitLab Runner 将存储`$CI_BUILDS_DIR`到`$CI_BUILDS_DIR`目录的唯一子路径中. 但是，您的项目可能需要特定目录中的代码（例如，Go 项目）. 在这种情况下，您可以指定`GIT_CLONE_PATH`变量，以告知 Runner 在哪个目录中克隆存储库：

```
variables:
  GIT_CLONE_PATH: $CI_BUILDS_DIR/project-name

test:
  script:
    - pwd 
```

`GIT_CLONE_PATH`必须始终在`$CI_BUILDS_DIR` . `$CI_BUILDS_DIR`设置的目录取决于执行程序和[runners.builds_dir](https://docs.gitlab.com/runner/configuration/advanced-configuration.html)设置的配置.

#### Handling concurrency[](#handling-concurrency "Permalink")

使用并发性大于`1`的执行程序可能会导致失败，因为如果在作业之间共享`builds_dir`则多个作业可能在同一目录上工作. GitLab Runner 不会尝试防止这种情况. 管理员和开发人员必须遵守 Runner 配置的要求.

为了避免这种情况，您可以在`$CI_BUILDS_DIR`内使用唯一路径，因为 Runner 公开了两个提供唯一并发`ID`的变量：

*   `$CI_CONCURRENT_ID` ：给定执行程序中运行的所有作业的唯一 ID.
*   `$CI_CONCURRENT_PROJECT_ID` ：给定执行程序和项目中运行的所有作业的唯一 ID.

在任何情况下以及在任何执行程序上都应能正常工作的最稳定的配置是在`$CI_CONCURRENT_ID`中使用`$CI_CONCURRENT_ID` `GIT_CLONE_PATH` . 例如：

```
variables:
  GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_CONCURRENT_ID/project-name

test:
  script:
    - pwd 
```

在`$CI_CONCURRENT_PROJECT_ID`应结合使用`$CI_PROJECT_PATH`为`$CI_PROJECT_PATH`提供了一个存储库的路径. 即`group/subgroup/project` . 例如：

```
variables:
  GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_CONCURRENT_ID/$CI_PROJECT_PATH

test:
  script:
    - pwd 
```

#### Nested paths[](#nested-paths "Permalink")

`GIT_CLONE_PATH`的值被扩展一次，并且不支持其中的嵌套变量.

例如，您在`.gitlab-ci.yml`文件中定义以下两个变量：

```
variables:
  GOPATH: $CI_BUILDS_DIR/go
  GIT_CLONE_PATH: $GOPATH/src/namespace/project 
```

`GIT_CLONE_PATH`的值一次扩展到`$CI_BUILDS_DIR/go/src/namespace/project` ，并且由于`$CI_BUILDS_DIR`没有扩展而导致失败.

## Special YAML features[](#special-yaml-features "Permalink")

可以使用特殊的 YAML 功能，例如锚点（ `&` ），别名（ `*` ）和地图合并（ `<<` ），这将使您大大降低`.gitlab-ci.yml`的复杂性.

阅读有关各种[YAML 功能的](https://learnxinyminutes.com/docs/yaml/)更多信息.

在大多数情况下， [`extends`关键字](#extends)更加用户友好，应该在这些特殊的 YAML 功能上使用. 可能仍需要使用 YAML 锚来合并数组.

### Anchors[](#anchors "Permalink")

在 GitLab 8.6 和 GitLab Runner v1.1.1 中引入.

YAML 具有称为"锚"的便捷功能，使您可以轻松地在整个文档中复制内容. 锚可用于复制/继承属性，并且是与[隐藏作业](#hide-jobs)一起使用以为您的作业提供模板的完美示例. 当有重复的密钥时，GitLab 将基于密钥执行反向深度合并.

以下示例使用锚点和地图合并. 它将创建两个作业`test1`和`test2` ，它们将继承`.job_template`的参数，每个参数都定义了自己的自定义`script` ：

```
.job_template: &job_definition  # Hidden key that defines an anchor named 'job_definition'
  image: ruby:2.6
  services:
    - postgres
    - redis

test1:
  <<: *job_definition           # Merge the contents of the 'job_definition' alias
  script:
    - test1 project

test2:
  <<: *job_definition           # Merge the contents of the 'job_definition' alias
  script:
    - test2 project 
```

`&`设置锚点的名称（ `job_definition` ）， `<<`表示"将给定的哈希值合并到当前哈希中"，并且`*`包括命名的锚点（再次为`job_definition` ）. 扩展版本如下所示：

```
.job_template:
  image: ruby:2.6
  services:
    - postgres
    - redis

test1:
  image: ruby:2.6
  services:
    - postgres
    - redis
  script:
    - test1 project

test2:
  image: ruby:2.6
  services:
    - postgres
    - redis
  script:
    - test2 project 
```

让我们来看另一个例子. 这次，我们将使用锚来定义两组服务. 这将创建两个作业： `test:postgres`和`test:mysql` ，它们将共享`.job_template`定义的`script`指令以及`.postgres_services`和`.mysql_services`定义的`services`指令：

```
.job_template: &job_definition
  script:
    - test project
  tags:
    - dev

.postgres_services:
  services: &postgres_definition
    - postgres
    - ruby

.mysql_services:
  services: &mysql_definition
    - mysql
    - ruby

test:postgres:
  <<: *job_definition
  services: *postgres_definition
  tags:
    - postgres

test:mysql:
  <<: *job_definition
  services: *mysql_definition 
```

扩展版本如下所示：

```
.job_template:
  script:
    - test project
  tags:
    - dev

.postgres_services:
  services:
    - postgres
    - ruby

.mysql_services:
  services:
    - mysql
    - ruby

test:postgres:
  script:
    - test project
  services:
    - postgres
    - ruby
  tags:
    - postgres

test:mysql:
  script:
    - test project
  services:
    - mysql
    - ruby
  tags:
    - dev 
```

您可以看到隐藏的作业可以方便地用作模板.

**Note:** Note that `tags: [dev]` has been overwritten by `tags: [postgres]`.**注意：**利用[`include`](#include)功能时，不能在多个文件中使用 YAML 锚. 锚仅在定义它们的文件内有效.您可以使用[`extends`关键字](#extends)来代替使用 YAML 锚.

#### YAML anchors for `before_script` and `after_script`[](#yaml-anchors-for-before_script-and-after_script "Permalink")

在 GitLab 12.5 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/23005) .

您可以将[YAML 定位](#anchors) `after_script`与`before_script`和`after_script` ，从而可以在多个作业中包括预定义的命令列表.

Example:

```
.something_before: &something_before
  - echo 'something before'

.something_after: &something_after
  - echo 'something after'
  - echo 'another thing after'

job_name:
  before_script:
    - *something_before
  script:
    - echo 'this is the script'
  after_script:
    - *something_after 
```

#### YAML anchors for `script`[](#yaml-anchors-for-script "Permalink")

在 GitLab 12.5 中[引入](https://gitlab.com/gitlab-org/gitlab/-/issues/23005) .

您可以将[YAML 锚点](#anchors)与脚本一起使用，从而可以在多个作业中包括预定义的命令列表.

例如：

```
.something: &something
  - echo 'something'

job_name:
  script:
    - *something
    - echo 'this is the script' 
```

#### YAML anchors for variables[](#yaml-anchors-for-variables "Permalink")

[YAML 锚](#anchors)可以与`variables`一起使用，以轻松地在多个作业之间重复分配变量. 当作业需要特定的`variables`块（否则将覆盖全局变量）时，它还可以提供更大的灵活性.

在下面的示例中，我们将覆盖`GIT_STRATEGY`变量，而不会影响`SAMPLE_VARIABLE`变量的使用：

```
# global variables
variables: &global-variables
  SAMPLE_VARIABLE: sample_variable_value
  ANOTHER_SAMPLE_VARIABLE: another_sample_variable_value

# a job that needs to set the GIT_STRATEGY variable, yet depend on global variables
job_no_git_strategy:
  stage: cleanup
  variables:
    <<: *global-variables
    GIT_STRATEGY: none
  script: echo $SAMPLE_VARIABLE 
```

### Hide jobs[](#hide-jobs "Permalink")

在 GitLab 8.6 和 GitLab Runner v1.1.1 中引入.

如果要临时"禁用"作业，而不是注释掉定义作业的所有行：

```
#hidden_job:
#  script:
#    - run test 
```

您可以改为以点号（ `.` ）开头，GitLab CI / CD 不会对其进行处理. 在以下示例中， `.hidden_job`将被忽略：

```
.hidden_job:
  script:
    - run test 
```

使用此功能可忽略作业，或使用[特殊的 YAML 功能](#special-yaml-features)并将隐藏的作业转换为模板.

## Skip Pipeline[](#skip-pipeline "Permalink")

如果您的提交消息包含`[ci skip]`或`[skip ci]` ，则使用大写字母将创建提交，但是将跳过管道.

或者，如果使用 Git 2.10 或更高版本，则可以传递`ci.skip` [Git 推送选项](../../user/project/push_options.html#push-options-for-gitlab-cicd) .

## Processing Git pushes[](#processing-git-pushes "Permalink")

当在单个`git push`调用中推送多个更改时，GitLab 将最多创建 4 条分支和标签管道.

此限制不影响任何更新的合并请求管道. 使用[合并请求](../merge_request_pipelines/index.html)管道时，所有更新的合并请求都将创建一个管道.

## Deprecated parameters[](#deprecated-parameters "Permalink")

不推荐使用以下参数.

### Globally-defined `types`[](#globally-defined-types "Permalink")

**不**推荐**使用：** `types`不推荐使用，可以在以后的版本中删除. 使用[`stages`](#stages)代替.

### Job-defined `type`[](#job-defined-type "Permalink")

**不**推荐**使用：** `type`不推荐使用，可以在将来的发行版之一中将其删除. 使用[`stage`](#stage)代替.

### Globally-defined `image`, `services`, `cache`, `before_script`, `after_script`[](#globally-defined-image-services-cache-before_script-after_script "Permalink")

不`after_script`全局定义`image` ， `services` ， `cache` ， `before_script`和`after_script` . 支持可以从将来的版本中删除.

使用[`default:`](#global-defaults)代替. 例如：

```
default:
  image: ruby:2.5
  services:
    - docker:dind
  cache:
    paths: [vendor/]
  before_script:
    - bundle install --path vendor/
  after_script:
    - rm -rf tmp/ 
```